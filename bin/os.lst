     1                                  ; Copyright (c) 2013, Daniel Lopez
     2                                  ;All rights reserved.
     3                                  ;
     4                                  ;Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
     5                                  ;
     6                                  ;Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
     7                                  ;Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
     8                                  ;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICUL
     9                                  
    10                                  ;Kernel
    11                                  
    12                                  [ORG 0x7e00]
    13                                  
    14 00000000 E94E02                  jmp main
    15                                  
    16                                  %include "syscalls.inc"
    17                              <1> ; Copyright (c) 2013, Daniel Lopez
    18                              <1> ;All rights reserved.
    19                              <1> ;
    20                              <1> ;Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    21                              <1> ;
    22                              <1> ;Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    23                              <1> ;Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
    24                              <1> ;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICUL
    25                              <1> 
    26                              <1> 
    27                              <1> 
    28                              <1> ; Initialize Interrupts
    29                              <1> init_int:
    30                              <1> 
    31 00000003 60                  <1> pusha
    32                              <1> 
    33 00000004 31C0                <1> xor ax, ax
    34 00000006 8EC0                <1> mov es, ax ; es = 0
    35                              <1> 
    36                              <1> ; Add the interrupt entry 
    37                              <1> 
    38 00000008 BA[4102]            <1> mov dx, int_print 
    39 0000000B 2689168400          <1> mov [es:21h*4], dx
    40 00000010 B80000              <1> mov ax, 0
    41 00000013 26A38600            <1> mov [es:21h*4 + 2], ax
    42                              <1> 
    43                              <1> ; Add another interrupt entry
    44                              <1> 
    45 00000017 BA[F101]            <1> mov dx, int_block_input_echo 
    46 0000001A 2689168800          <1> mov [es:22h*4], dx
    47 0000001F B80000              <1> mov ax, 0
    48 00000022 26A38A00            <1> mov [es:22h*4 + 2], ax
    49                              <1> 
    50                              <1> ; Add another interrupt entry
    51                              <1> 
    52 00000026 BA[3202]            <1> mov dx, int_print_newline 
    53 00000029 2689168C00          <1> mov [es:23h*4], dx
    54 0000002E B80000              <1> mov ax, 0
    55 00000031 26A38E00            <1> mov [es:23h*4 + 2], ax
    56                              <1> 
    57                              <1> ; Add another interrupt entry
    58                              <1> 
    59 00000035 BA[DF01]            <1> mov dx, int_zero_buffer 
    60 00000038 2689169000          <1> mov [es:24h*4], dx
    61 0000003D B80000              <1> mov ax, 0
    62 00000040 26A39200            <1> mov [es:24h*4 + 2], ax
    63                              <1> 
    64                              <1> ; Add another interrupt entry
    65                              <1> 
    66 00000044 BA[CF01]            <1> mov dx, int_string_length 
    67 00000047 2689169400          <1> mov [es:25h*4], dx
    68 0000004C B80000              <1> mov ax, 0
    69 0000004F 26A39600            <1> mov [es:25h*4 + 2], ax
    70                              <1> 
    71                              <1> ; Add another interrupt entry
    72                              <1> 
    73 00000053 BA[AB01]            <1> mov dx, int_integer_to_string
    74 00000056 2689169800          <1> mov [es:26h*4], dx
    75 0000005B B80000              <1> mov ax, 0
    76 0000005E 26A39A00            <1> mov [es:26h*4 + 2], ax
    77                              <1> 
    78                              <1> ; Add another interrupt entry
    79                              <1> 
    80 00000062 BA[A201]            <1> mov dx, int_clear_screen
    81 00000065 2689169C00          <1> mov [es:27h*4], dx
    82 0000006A B80000              <1> mov ax, 0
    83 0000006D 26A39E00            <1> mov [es:27h*4 + 2], ax
    84                              <1> 
    85                              <1> ; Add another interrupt entry
    86                              <1> 
    87 00000071 BA[5E01]            <1> mov dx, int_check_file_struct
    88 00000074 268916A000          <1> mov [es:28h*4], dx
    89 00000079 B80000              <1> mov ax, 0
    90 0000007C 26A3A200            <1> mov [es:28h*4 + 2], ax
    91                              <1> 
    92                              <1> ; Add another interrupt entry
    93                              <1> 
    94 00000080 BA[8601]            <1> mov dx, int_write_file_struct
    95 00000083 268916A400          <1> mov [es:29h*4], dx
    96 00000088 B80000              <1> mov ax, 0
    97 0000008B 26A3A600            <1> mov [es:29h*4 + 2], ax
    98                              <1> 
    99                              <1> ; Add another interrupt entry
   100                              <1> 
   101 0000008F BA[3B01]            <1> mov dx, int_string_compare
   102 00000092 268916C000          <1> mov [es:30h*4], dx
   103 00000097 B80000              <1> mov ax, 0
   104 0000009A 26A3C200            <1> mov [es:30h*4 + 2], ax
   105                              <1> 
   106                              <1> ; Add another interrupt entry
   107                              <1> 
   108 0000009E BA[E100]            <1> mov dx, int_load_program_by_filename
   109 000000A1 268916C400          <1> mov [es:31h*4], dx
   110 000000A6 B80000              <1> mov ax, 0
   111 000000A9 26A3C600            <1> mov [es:31h*4 + 2], ax
   112                              <1> 
   113                              <1> ; Add another interrupt entry
   114                              <1> 
   115 000000AD BA[BE00]            <1> mov dx, int_list_files_from_file_table
   116 000000B0 268916C800          <1> mov [es:32h*4], dx
   117 000000B5 B80000              <1> mov ax, 0
   118 000000B8 26A3CA00            <1> mov [es:32h*4 + 2], ax
   119                              <1> 
   120 000000BC 61                  <1> popa
   121                              <1> 
   122 000000BD C3                  <1> ret
   123                              <1> 
   124                              <1> ;-----------------------------------------------------------------
   125                              <1> ;Prints each file name from the file table located at 0x9e00
   126                              <1> 
   127                              <1> int_list_files_from_file_table:
   128                              <1> 
   129 000000BE 60                  <1> pusha
   130                              <1> 	
   131 000000BF B9019E              <1> 	mov cx, 0x9e01
   132 000000C2 BA0000              <1> 	mov dx, 0
   133                              <1> _loop___:
   134 000000C5 83FA05              <1> 	cmp dx, 5
   135 000000C8 7415                <1> 	je _exit____ ; Exit loop because there are not more FILE structure entries
   136 000000CA 89CE                <1> 	mov si, cx
   137 000000CC 8A04                <1> 	mov al, byte[si]
   138 000000CE 3C00                <1> 	cmp al, 0
   139 000000D0 740D                <1> 	je _exit____ ; Exit if null string is found
   140 000000D2 89C8                <1> 	mov ax, cx
   141 000000D4 CD21                <1> 	int 21h ; Print filename
   142 000000D6 CD23                <1> 	int 23h ; Print new line
   143 000000D8 81C10002            <1> 	add cx, 0x200
   144 000000DC 42                  <1> 	inc dx
   145 000000DD EBE6                <1> 	jmp _loop___
   146                              <1> 
   147                              <1> _exit____:	
   148                              <1> 
   149 000000DF 61                  <1> popa 
   150                              <1> 
   151 000000E0 CF                  <1> iret
   152                              <1> 
   153                              <1> ;-----------------------------------------------------------------
   154                              <1> ; Loads Program into memory. Using the filename of the program.
   155                              <1> ; AX=Contains starting address of null-terminated string
   156                              <1> ;
   157                              <1> int_load_program_by_filename:
   158                              <1> 
   159 000000E1 60                  <1> pusha
   160                              <1> 
   161 000000E2 B9019E              <1> 	mov cx, 0x9e01
   162 000000E5 BA0000              <1> 	mov dx, 0
   163                              <1> _loop__:
   164 000000E8 83FA0A              <1> 	cmp dx, 10
   165 000000EB 7416                <1> 	je no_program_found ; Exit loop because there are no more FILE structure entries in the file table
   166 000000ED 89CE                <1> 	mov si, cx
   167 000000EF 803C00              <1> 	cmp byte[si], 0
   168 000000F2 740F                <1> 	je no_program_found ; Exit if null string is found
   169 000000F4 89CB                <1> 	mov bx, cx ; bx <- cx
   170 000000F6 CD30                <1> 	int 30h
   171 000000F8 09D2                <1> 	or dx, dx
   172 000000FA 7411                <1> 	jz found_program ; If strings match then jump to found_program and start executing the program from memory
   173 000000FC 81C10002            <1> 	add cx, 0x200
   174 00000100 42                  <1> 	inc dx
   175 00000101 EBE5                <1> 	jmp _loop__
   176                              <1> 	
   177                              <1> no_program_found:
   178                              <1> 
   179 00000103 B8[CD04]            <1> 	mov ax, invalid_cmd
   180 00000106 BB0F00              <1> 	mov bx, 000fh
   181 00000109 CD21                <1> 	int 21h ; Print invalid command message
   182                              <1> 
   183 0000010B EB2C                <1> jmp _exit___
   184                              <1> 	
   185                              <1> found_program:
   186 0000010D 83C10D              <1> 	add cx, 13
   187 00000110 89CE                <1> 	mov si, cx
   188 00000112 803C00              <1> 	cmp byte[si], 0
   189 00000115 7407                <1> 	je exec ; if al == 0 then file is program needs to be executed
   190                              <1> 	
   191 00000117 41                  <1> 	inc cx
   192 00000118 89C8                <1> 	mov ax, cx
   193 0000011A CD21                <1> 	int 21h
   194                              <1> 	
   195 0000011C EB1B                <1> 	jmp _exit___
   196                              <1> 	
   197                              <1> exec:
   198                              <1> 	copy_prog_in_mem: ; Copies program into 0x9999 because that is where all programs are loaded and executed
   199 0000011E 41                  <1> 			inc cx
   200 0000011F 89CB                <1> 			mov bx, cx ; bx <- cx because cx cannot be used for this operation
   201 00000121 BF9999              <1> 			mov di, 0x9999 ; Destination index is 0x9999 because that is where the program will be loaded
   202 00000124 BA0000              <1> 			mov dx, 0 ; our counter
   203                              <1> 			looop:
   204 00000127 81FAF101            <1> 			cmp dx, 497 ; 497 because 497 is the maximum number of bytes a program can be. Remember each file table entry occupies 512 bytes
   205 0000012B 7409                <1> 			je _call ; if dx = 497 then the program has been fully copied to the region in memory where it will be executed
   206 0000012D 8B37                <1> 			mov  si, [bx] ; copy contents at address bx into source index
   207 0000012F 8935                <1> 			mov [di], si ; Move contents at source index and store it into the memory address at destination index
   208 00000131 42                  <1> 			inc dx ; increment dx
   209 00000132 47                  <1> 			inc di ; increment destination index
   210 00000133 43                  <1> 			inc bx ; increment bx
   211 00000134 EBF1                <1> 			jmp looop
   212                              <1> 	_call:
   213 00000136 E8(9999)            <1> 			call 0x9999 
   214                              <1> _exit___:
   215                              <1> 	
   216 00000139 61                  <1> popa
   217                              <1> 
   218                              <1> 
   219 0000013A CF                  <1> iret
   220                              <1> 
   221                              <1> ;-----------------------------------------------------------------
   222                              <1> ; Compares two strings
   223                              <1> ; AX=Address of String1 BX=Address of String2 
   224                              <1> ; Returns DX=0 equal any other value means not equal
   225                              <1> int_string_compare:
   226                              <1> 
   227 0000013B 51                  <1> push cx ; save cx
   228                              <1> 
   229 0000013C CD25                <1> int 25h ; Get String Length of String1
   230 0000013E 89CA                <1> mov dx, cx
   231 00000140 50                  <1> push ax ; save ax
   232 00000141 89D8                <1> mov ax, bx
   233 00000143 CD25                <1> int 25h
   234 00000145 58                  <1> pop ax
   235 00000146 39CA                <1> cmp dx, cx
   236 00000148 7F02                <1> jg doit ; dx > cx
   237 0000014A 89D1                <1> mov cx, dx
   238                              <1> 
   239                              <1> doit:
   240 0000014C 89C6                <1> 	mov si, ax
   241 0000014E 89DF                <1> 	mov di, bx
   242 00000150 F3A6                <1> 	rep cmpsb
   243 00000152 7405                <1> 	je identical
   244                              <1> 
   245 00000154 BA0100              <1> 	mov dx, 1
   246 00000157 EB03                <1> 	jmp finish_it
   247                              <1> identical:
   248 00000159 BA0000              <1> 	mov dx, 0
   249                              <1> finish_it:
   250                              <1> 
   251 0000015C 59                  <1> pop cx ; restore cx
   252                              <1> 
   253 0000015D CF                  <1> iret
   254                              <1> 
   255                              <1> ;-----------------------------------------------------------------
   256                              <1> ; Checks To See If An Existing FILE structure exists on a specific sector on the disk
   257                              <1> ; Params: AX = Sector To Check If FILE 
   258                              <1> ; Returns The Status In AX. If AX is zero there is an existing FILE structure currently on the disk.
   259                              <1> ; Any other value would mean it is safe to write a FILE structure at that sector
   260                              <1> int_check_file_struct:
   261                              <1> 
   262 0000015E 51                  <1> push cx
   263 0000015F 06                  <1> push es
   264 00000160 52                  <1> push dx
   265 00000161 53                  <1> push bx
   266                              <1> 
   267 00000162 89C1                <1> mov cx, ax    ; Sector ax
   268 00000164 31C0                <1> xor ax, ax
   269 00000166 8EC0                <1> mov es, ax    ; ES <- 0
   270 00000168 BA8000              <1> mov dx, 0080h ; DH = 0 (head), drive = 80h (0th hard disk)
   271 0000016B BB0020              <1> mov bx, 2000h ; segment offset of the buffer
   272 0000016E B80102              <1> mov ax, 0201h ; AH = 02 (disk read), AL = 01 (number of sectors to read)
   273 00000171 CD13                <1> int 13h
   274                              <1> 
   275 00000173 8B0F                <1> mov cx, [bx]
   276 00000175 83F969              <1> cmp cx, 0x69
   277 00000178 7405                <1> je file_exists
   278                              <1> 
   279 0000017A B80100              <1> mov ax, 1
   280                              <1> 
   281 0000017D EB02                <1> jmp __exit ; File doesnt exist
   282                              <1> 
   283                              <1> file_exists:
   284                              <1> 
   285 0000017F 31C0                <1> xor ax, ax
   286                              <1> 
   287                              <1> __exit:
   288                              <1> 
   289                              <1> 
   290 00000181 5B                  <1> pop bx
   291 00000182 5A                  <1> pop dx
   292 00000183 07                  <1> pop es
   293 00000184 59                  <1> pop cx
   294                              <1> 
   295 00000185 CF                  <1> iret
   296                              <1> 
   297                              <1> ;-----------------------------------------------------------------
   298                              <1> ; Writes A FILE structure on the disk. 
   299                              <1> ; Params: BX=Starting Address of FILE structure CX=Sector To Write
   300                              <1> ; Returns AX= -1 if failed to write 
   301                              <1> int_write_file_struct:
   302                              <1> 
   303 00000186 60                  <1> pusha
   304                              <1> 
   305 00000187 89D8                <1> 	mov ax, bx
   306 00000189 CD28                <1> 	int 28h
   307 0000018B 09C0                <1> 	or ax, ax
   308 0000018D 740E                <1> 	jz _error_
   309                              <1> 	
   310 0000018F 31C0                <1> 	xor ax, ax
   311 00000191 8EC0                <1> 	mov es, ax    ; ES <- 0
   312 00000193 BA8000              <1> 	mov dx, 0080h ; DH = 0 (head), drive = 80h (0th hard disk)
   313 00000196 B80103              <1> 	mov ax, 0301h ; AH = 03 (disk write), AL = 01 (number of sectors to write)
   314 00000199 CD13                <1> 	int 13h
   315                              <1> 	
   316 0000019B EB03                <1> 	jmp _____exit
   317                              <1> 	
   318                              <1> _error_:
   319                              <1> 
   320 0000019D B8FFFF              <1> 	mov ax, -1
   321                              <1> 
   322                              <1> _____exit:
   323                              <1> 	
   324 000001A0 61                  <1> popa
   325                              <1> 
   326 000001A1 CF                  <1> iret 
   327                              <1> 
   328                              <1> ;-----------------------------------------------------------------
   329                              <1> 
   330                              <1> int_clear_screen:
   331                              <1> 
   332 000001A2 60                  <1> pusha
   333 000001A3 B400                <1> 		mov ah, 0
   334 000001A5 B003                <1> 		mov al, 3h
   335 000001A7 CD10                <1> 		int 10h
   336                              <1> 
   337 000001A9 61                  <1> popa
   338                              <1> 
   339 000001AA CF                  <1> iret
   340                              <1> 
   341                              <1> ;-----------------------------------------------------------------
   342                              <1> 
   343                              <1> ;Converts an integer into a string
   344                              <1> ;Params: ax has the integer value, bx has the pointer to the string buffer
   345                              <1> ;Returns nothing
   346                              <1> ;This is an ISR
   347                              <1> 
   348                              <1> int_integer_to_string:
   349                              <1> 
   350 000001AB 52                  <1>    push dx
   351 000001AC 51                  <1>    push cx
   352 000001AD 53                  <1>    push bx
   353 000001AE 50                  <1>    push ax
   354                              <1>    
   355 000001AF 89DF                <1>    mov di, bx
   356                              <1>    
   357 000001B1 BB0A00              <1>    mov bx, 10               ; base of the decimal system
   358 000001B4 31C9                <1>    xor cx, cx               ; number of digits generated
   359                              <1> os_int_to_string_next_divide:
   360 000001B6 31D2                <1>    xor dx, dx               ; RAX extended to (RDX,RAX)
   361 000001B8 F7F3                <1>    div bx                  ; divide by the number-base
   362 000001BA 52                  <1>    push dx               ; save remainder on the stack
   363 000001BB 41                  <1>    inc cx                  ; and count this remainder
   364 000001BC 83F800              <1>    cmp ax, 0               ; was the quotient zero?
   365 000001BF 75F5                <1>    jne os_int_to_string_next_divide      ; no, do another division
   366                              <1> 
   367                              <1> os_int_to_string_next_digit:
   368 000001C1 58                  <1>    pop ax                  ; else pop recent remainder
   369 000001C2 0430                <1>    add al, '0'               ; and convert to a numeral
   370 000001C4 AA                  <1>    stosb                  ; store to memory-buffer
   371 000001C5 E2FA                <1>    loop os_int_to_string_next_digit      ; again for other remainders
   372 000001C7 30C0                <1>    xor al, al
   373 000001C9 AA                  <1>    stosb                  ; Store the null terminator at the end of the string
   374                              <1> 
   375 000001CA 58                  <1>    pop ax
   376 000001CB 5B                  <1>    pop bx
   377 000001CC 59                  <1>    pop cx
   378 000001CD 5A                  <1>    pop dx
   379                              <1>    
   380 000001CE CF                  <1>    iret
   381                              <1>    
   382                              <1>    
   383                              <1>    
   384                              <1> ; -----------------------------------------------------------------------------
   385                              <1> 
   386                              <1> ;Computes String (Null Terminated) Length
   387                              <1> ;Params: Starting Address Stored In AX
   388                              <1> ;Returns Length  At CX
   389                              <1> ;This is an ISR
   390                              <1> int_string_length:
   391                              <1> 
   392 000001CF 50                  <1> push ax ; Save
   393 000001D0 89C6                <1> 	mov si, ax
   394 000001D2 B90000              <1> 	mov cx, 0
   395                              <1> 	loopy:
   396                              <1> 	
   397 000001D5 AC                  <1> 			lodsb
   398 000001D6 08C0                <1> 			or al, al
   399 000001D8 7403                <1> 			jz exity
   400 000001DA 41                  <1> 			inc cx
   401 000001DB EBF8                <1> 			jmp loopy
   402                              <1> 	exity:
   403 000001DD 58                  <1> pop ax ; Restore
   404                              <1> 
   405 000001DE CF                  <1> iret
   406                              <1> 
   407                              <1> ;----------------------------------------------------------------------------------
   408                              <1> 
   409                              <1> ; Fills the buffer with zeroes.
   410                              <1> ; Params: Starting Address of Buffer Stored In AX, BX Contains String Length
   411                              <1> ; This is a ISR no direct invoking
   412                              <1> 
   413                              <1> int_zero_buffer:
   414                              <1> 
   415 000001DF 60                  <1> pusha
   416                              <1> 
   417 000001E0 89C7                <1> 	mov di, ax
   418 000001E2 B90000              <1>     mov cx, 0
   419                              <1> 	
   420                              <1> 	l:
   421 000001E5 B000                <1> 	mov al, 0
   422 000001E7 AA                  <1> 	stosb
   423 000001E8 39D9                <1> 	cmp cx, bx
   424 000001EA 7403                <1> 	je e ; if cx == bx goto e
   425 000001EC 41                  <1> 	inc cx ; cx++
   426 000001ED EBF6                <1> 	jmp l ; Go back to the beginning of the loop
   427                              <1> 	
   428                              <1> 	e:
   429                              <1> 
   430 000001EF 61                  <1> popa
   431                              <1> 
   432 000001F0 CF                  <1> iret
   433                              <1> 
   434                              <1> ;---------------------------------------------------------------------------------------------------------
   435                              <1> 
   436                              <1> ; Reads Each Character Until Enter Has Been Pressed. This ISR Can ECHO each Character
   437                              <1> ; Params: AX Starting Address Of String
   438                              <1> ; This is a ISR no direct invoking
   439                              <1> int_block_input_echo:
   440                              <1> 
   441 000001F1 60                  <1> 	pusha
   442                              <1> 	
   443 000001F2 89DF                <1> 	mov di, bx
   444 000001F4 B90000              <1> 	mov cx, 0
   445                              <1> 	
   446                              <1> 	_again_:
   447                              <1> 
   448 000001F7 83F90C              <1> 	cmp cx, 12 ; Prompt cannot accept more than 12 characters
   449 000001FA 7425                <1> 	je _max_reached ; We jump to end if cx equals to 12
   450                              <1> 	
   451 000001FC B400                <1> 	mov ah, 0
   452 000001FE CD16                <1> 	int 0x16
   453 00000200 3C08                <1> 	cmp al, 0x8
   454 00000202 7505                <1> 	jne print
   455 00000204 83F900              <1> 	cmp cx, 0
   456 00000207 74EE                <1> 	je _again_ ; Ignore print backspace if cursor is already at the beginning
   457                              <1> print:
   458 00000209 B40E                <1> 	mov ah, 0Eh ; ah = 0x0e
   459 0000020B CD10                <1> 	int 0x10 ; print character
   460 0000020D 3C08                <1> 	cmp al, 0x8 ; compare al with backspace
   461 0000020F 7408                <1> 	je _ignore ; If backspace we ignore it and avoid adding into the buffer.
   462 00000211 3C0D                <1> 	cmp al, 0xD ; compare with line feed
   463 00000213 7412                <1> 	je _end_ ; if al='\r' break from loop
   464 00000215 AA                  <1> 	stosb ; Store Character Byte At AL Into [ES:DI] Then INCREMENTS DI
   465 00000216 41                  <1> 	inc cx ; cx++
   466 00000217 EBDE                <1> 	jmp _again_ ; else go back to the beginning of the loop
   467                              <1> 	_ignore: 
   468 00000219 49                  <1> 	dec cx ; cx-- because we pressed backspace
   469 0000021A 39DF                <1> 	cmp di, bx
   470 0000021C 74D9                <1> 	je _again_ ; if (di == buffer) we do not want to decrement di 
   471 0000021E 4F                  <1> 	dec di
   472 0000021F EBD6                <1> 	jmp _again_ ; else go back to the beginning of the loop
   473                              <1> 	
   474                              <1> 
   475                              <1> 	
   476                              <1> 	_max_reached:
   477                              <1> 	
   478 00000221 B40E                <1> 	mov ah, 0Eh ; ah = 0x0e
   479 00000223 B00D                <1> 	mov al, 0xD
   480 00000225 CD10                <1> 	int 0x10 ; print character
   481                              <1> 	
   482                              <1> 	_end_:	
   483                              <1> 	
   484 00000227 B000                <1> 	mov al, 0
   485 00000229 AA                  <1> 	stosb
   486                              <1> 	
   487 0000022A B40E                <1>     mov ah, 0Eh
   488 0000022C B00A                <1> 	mov al, 10
   489 0000022E CD10                <1> 	int 0x10 ; Print New Line
   490                              <1> 	 
   491 00000230 61                  <1> 	popa
   492                              <1> 
   493 00000231 CF                  <1> iret 
   494                              <1> 
   495                              <1> ;--------------------------------------------------------------------------------------------------------------------------
   496                              <1> 
   497                              <1> ;Prints a single new line character
   498                              <1> ; This is a ISR
   499                              <1> int_print_newline:
   500                              <1> 
   501 00000232 60                  <1> pusha
   502                              <1> 
   503 00000233 B40E                <1> 		mov ah, 0Eh
   504 00000235 B00D                <1> 		mov al, 13
   505 00000237 CD10                <1> 		int 0x10 ; Print New Line
   506                              <1> 
   507 00000239 B40E                <1> 		mov ah, 0Eh
   508 0000023B B00A                <1> 		mov al, 10
   509 0000023D CD10                <1> 		int 0x10 ; Print New Line
   510                              <1> 		
   511 0000023F 61                  <1> popa
   512                              <1> 
   513 00000240 CF                  <1> iret
   514                              <1> 
   515                              <1> ; Prints a null terminated string on the screen
   516                              <1> ; This is ISR (Interrupt Service Routine)
   517                              <1> int_print:
   518 00000241 60                  <1> 	pusha ; Store all working registers on the stack!
   519 00000242 89C6                <1> 	mov si, ax
   520                              <1> 
   521                              <1> 	.loop:
   522 00000244 AC                  <1> 			lodsb
   523 00000245 08C0                <1> 			or al, al
   524 00000247 7406                <1> 			jz .endloop ; If character is a null character aka 0 then end the loop			
   525 00000249 B40E                <1> 			mov ah, 0Eh ; ah = 0x0e
   526 0000024B CD10                <1> 			int 0x10 ; print character
   527 0000024D EBF5                <1> 			jmp .loop ; Go back to the beginning of the loop
   528                              <1> 	.endloop:
   529 0000024F 61                  <1> 	popa ; Pop all the saved registers on the stack and restore them!
   530 00000250 CF                  <1> iret ; Return from interrupt
   531                              <1> 
   532                              <1> ;------------------------------------------------------------------------------------------------------
   533                                  
   534                                  
   535                                  
   536                                  main:
   537                                  
   538 00000251 E8AFFD                  call init_int
   539                                  
   540 00000254 31C0                    xor ax, ax ; make it zero
   541 00000256 8ED8                    mov ds, ax ; Data segment is zero
   542 00000258 8EC0                    mov es, ax
   543                                  
   544                                  
   545                                  
   546                                  ; Clear Screen
   547                                  
   548 0000025A CD27                    int 27h
   549                                  
   550                                  ;Set desired background color (Green)
   551 0000025C B40B                    mov ah, 0x0b 
   552 0000025E B700                    mov bh, 0
   553 00000260 B302                    mov bl, 2
   554 00000262 CD10                    int 0x10	
   555                                  
   556                                  
   557                                  
   558                                  
   559                                  hang:
   560                                  	
   561                                  	; Print Desired Message
   562                                  
   563 00000264 B8[BC02]                	mov ax, cli_msg
   564 00000267 B700                    	mov bh, 0
   565 00000269 B30F                    	mov bl, 0xf
   566                                  
   567 0000026B CD21                    	int 21h ; print ax=msg bl=blue
   568                                  
   569                                  	; Get Input
   570 0000026D BB[F204]                	mov bx, buffer
   571 00000270 CD22                    	int 22h ; Read From Keyboard  And Store String In Buffer
   572                                  	
   573 00000272 BB[F204]                	mov bx, buffer
   574 00000275 B8[BD04]                	mov ax, internal_command_A
   575                                  	
   576 00000278 CD30                    	int 30h ; string compare buffer and commandA
   577                                  	
   578 0000027A 83FA00                  	cmp dx, 0 
   579                                  	
   580 0000027D 742F                    	je help_command ;if (buffer == command) goto help_command
   581                                  	
   582 0000027F BB[F204]                	mov bx, buffer
   583 00000282 B8[C204]                	mov ax, internal_command_B
   584                                  	
   585 00000285 CD30                    	int 30h ; string compare buffer and commandB
   586                                  	
   587 00000287 83FA00                  	cmp dx, 0 
   588                                  	
   589 0000028A 741E                    	je clear_command
   590                                  	
   591 0000028C BB[F204]                	mov bx, buffer
   592 0000028F B8[C804]                	mov ax, internal_command_C
   593                                  	
   594 00000292 CD30                    	int 30h ; string compare buffer and commandC
   595                                  	
   596 00000294 83FA00                  	cmp dx, 0 
   597                                  	
   598 00000297 7506                    	jne external_command
   599                                  	
   600                                  	
   601                                  list_command:
   602                                  
   603 00000299 CD23                    		int 23h ; Print newline
   604                                  
   605 0000029B CD32                    		int 32h ; List files from file table
   606                                  		
   607 0000029D EBC5                    		jmp hang
   608                                  	
   609                                  external_command:
   610                                  
   611 0000029F CD23                    		int 23h ; new line
   612 000002A1 B8[F204]                		mov ax, buffer
   613 000002A4 CD31                    		int 31h ; Check if buffer contains a valid filename and load and execute external command.
   614 000002A6 CD23                    		int 23h ; new line
   615 000002A8 EBBA                    		jmp hang
   616                                  		
   617                                  
   618                                  clear_command:
   619                                  
   620                                  		; Clear Screen
   621                                  
   622 000002AA CD27                    		int 27h
   623                                  		
   624 000002AC EBB6                    		jmp hang
   625                                  	
   626                                  help_command:
   627                                  
   628 000002AE CD23                    		int 23h ; Print newline
   629                                  
   630 000002B0 B8[CA02]                		mov ax, help_msg
   631 000002B3 BB0F00                  		mov bx, 000fh
   632 000002B6 CD21                    		int 21h ; Print help string
   633                                  
   634 000002B8 CD23                    		int 23h ; Print newline
   635                                  		
   636 000002BA EBA8                    		jmp hang
   637                                  	
   638 000002BC 0D0A4D6F6E73746572-     cli_msg: db 13, 10, 'MonsterOS> ', 0
   639 000002C5 4F533E2000         
   640 000002CA 57656C636F6D652074-     help_msg: db 'Welcome to the MonsterOS shell prompt.', 13, 10, 13, 10, 'MonsterOS shell prompt contains only two internal commands: help, clear, and list.', 13, 10, 'This means that MonsterOS treats everything else 
   641 000002D3 6F20746865204D6F6E-
   642 000002DC 737465724F53207368-
   643 000002E5 656C6C2070726F6D70-
   644 000002EE 742E0D0A0D0A4D6F6E-
   645 000002F7 737465724F53207368-
   646 00000300 656C6C2070726F6D70-
   647 00000309 7420636F6E7461696E-
   648 00000312 73206F6E6C79207477-
   649 0000031B 6F20696E7465726E61-
   650 00000324 6C20636F6D6D616E64-
   651 0000032D 733A2068656C702C20-
   652 00000336 636C6561722C20616E-
   653 0000033F 64206C6973742E0D0A-
   654 00000348 54686973206D65616E-
   655 00000351 732074686174204D6F-
   656 0000035A 6E737465724F532074-
   657 00000363 726561747320657665-
   658 0000036C 72797468696E672065-
   659 00000375 6C7365207468617420-
   660 0000037E 6973206E6F74207468-
   661 00000387 652068656C702F636C-
   662 00000390 65617220636F6D6D61-
   663 00000399 6E6420617320616E20-
   664 000003A2 65787465726E616C20-
   665 000003AB 636F6D6D616E642E0D-
   666 000003B4 0A416E206578746572-
   667 000003BD 6E616C20636F6D6D61-
   668 000003C6 6E6420697320626173-
   669 000003CF 6963616C6C79206120-
   670 000003D8 66696C656E616D6520-
   671 000003E1 6F6620612066696C65-
   672 000003EA 2073746F726564206F-
   673 000003F3 6E2074686520646973-
   674 000003FC 6B2E0A0D4966207468-
   675 00000405 652066696C65206973-
   676 0000040E 206C6F636174656420-
   677 00000417 6F6E20746865206469-
   678 00000420 736B20697420697320-
   679 00000429 657865637574656420-
   680 00000432 696620697420697320-
   681 0000043B 612070726F6772616D-
   682 00000444 3B20656C7365206974-
   683 0000044D 206973207472656174-
   684 00000456 656420612074657874-
   685 0000045F 2066696C6520616E64-
   686 00000468 2069747320636F6E74-
   687 00000471 656E74732061726520-
   688 0000047A 646973706C61796564-
   689 00000483 2E0D0A4966206E6F20-
   690 0000048C 66696C652069732066-
   691 00000495 6F756E64207468656E-
   692 0000049E 2061206572726F7220-
   693 000004A7 6D6573736167652069-
   694 000004B0 7320646973706C6179-
   695 000004B9 65642E00           
   696 000004BD 68656C7000              internal_command_A: db 'help', 0
   697 000004C2 636C65617200            internal_command_B: db 'clear', 0
   698 000004C8 6C69737400              internal_command_C: db 'list', 0
   699 000004CD 496E76616C69642049-     invalid_cmd: db 'Invalid Internal / External Command!',0
   700 000004D6 6E7465726E616C202F-
   701 000004DF 2045787465726E616C-
   702 000004E8 20436F6D6D616E6421-
   703 000004F1 00                 
   704 000004F2 00<rept>                buffer: times 8 db 0
   705                                  
