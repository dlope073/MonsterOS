     1                                  ; Copyright (c) 2014, Daniel Lopez
     2                                  ;All rights reserved.
     3                                  ;
     4                                  ;Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
     5                                  ;
     6                                  ;Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
     7                                  ;Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
     8                                  ;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICUL
     9                                  
    10                                  ;Kernel
    11                                  
    12                                  [ORG 0x7e00]
    13                                  
    14 00000000 E9C502                  jmp main
    15                                  
    16                                  %include "syscalls.inc"
    17                              <1> ; Copyright (c) 2014, Daniel Lopez
    18                              <1> ;All rights reserved.
    19                              <1> ;
    20                              <1> ;Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    21                              <1> ;
    22                              <1> ;Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    23                              <1> ;Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
    24                              <1> ;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICUL
    25                              <1> 
    26                              <1> 
    27                              <1> 
    28                              <1> ; Initialize Interrupts
    29                              <1> init_int:
    30                              <1> 
    31 00000003 60                  <1> pusha
    32                              <1> 
    33 00000004 31C0                <1> xor ax, ax
    34 00000006 8EC0                <1> mov es, ax ; es = 0
    35                              <1> 
    36                              <1> ; Add the interrupt entry 
    37                              <1> 
    38 00000008 BA[5D02]            <1> mov dx, int_print 
    39 0000000B 2689168400          <1> mov [es:21h*4], dx
    40 00000010 B80000              <1> mov ax, 0
    41 00000013 26A38600            <1> mov [es:21h*4 + 2], ax
    42                              <1> 
    43                              <1> ; Add another interrupt entry
    44                              <1> 
    45 00000017 BA[0D02]            <1> mov dx, int_block_input_echo 
    46 0000001A 2689168800          <1> mov [es:22h*4], dx
    47 0000001F B80000              <1> mov ax, 0
    48 00000022 26A38A00            <1> mov [es:22h*4 + 2], ax
    49                              <1> 
    50                              <1> ; Add another interrupt entry
    51                              <1> 
    52 00000026 BA[4E02]            <1> mov dx, int_print_newline 
    53 00000029 2689168C00          <1> mov [es:23h*4], dx
    54 0000002E B80000              <1> mov ax, 0
    55 00000031 26A38E00            <1> mov [es:23h*4 + 2], ax
    56                              <1> 
    57                              <1> ; Add another interrupt entry
    58                              <1> 
    59 00000035 BA[FB01]            <1> mov dx, int_zero_buffer 
    60 00000038 2689169000          <1> mov [es:24h*4], dx
    61 0000003D B80000              <1> mov ax, 0
    62 00000040 26A39200            <1> mov [es:24h*4 + 2], ax
    63                              <1> 
    64                              <1> ; Add another interrupt entry
    65                              <1> 
    66 00000044 BA[EB01]            <1> mov dx, int_string_length 
    67 00000047 2689169400          <1> mov [es:25h*4], dx
    68 0000004C B80000              <1> mov ax, 0
    69 0000004F 26A39600            <1> mov [es:25h*4 + 2], ax
    70                              <1> 
    71                              <1> ; Add another interrupt entry
    72                              <1> 
    73 00000053 BA[C701]            <1> mov dx, int_integer_to_string
    74 00000056 2689169800          <1> mov [es:26h*4], dx
    75 0000005B B80000              <1> mov ax, 0
    76 0000005E 26A39A00            <1> mov [es:26h*4 + 2], ax
    77                              <1> 
    78                              <1> ; Add another interrupt entry
    79                              <1> 
    80 00000062 BA[BE01]            <1> mov dx, int_clear_screen
    81 00000065 2689169C00          <1> mov [es:27h*4], dx
    82 0000006A B80000              <1> mov ax, 0
    83 0000006D 26A39E00            <1> mov [es:27h*4 + 2], ax
    84                              <1> 
    85                              <1> ; Add another interrupt entry
    86                              <1> 
    87 00000071 BA[7A01]            <1> mov dx, int_check_file_struct
    88 00000074 268916A000          <1> mov [es:28h*4], dx
    89 00000079 B80000              <1> mov ax, 0
    90 0000007C 26A3A200            <1> mov [es:28h*4 + 2], ax
    91                              <1> 
    92                              <1> ; Add another interrupt entry
    93                              <1> 
    94 00000080 BA[A201]            <1> mov dx, int_write_file_struct
    95 00000083 268916A400          <1> mov [es:29h*4], dx
    96 00000088 B80000              <1> mov ax, 0
    97 0000008B 26A3A600            <1> mov [es:29h*4 + 2], ax
    98                              <1> 
    99                              <1> ; Add another interrupt entry
   100                              <1> 
   101 0000008F BA[5901]            <1> mov dx, int_string_compare
   102 00000092 268916C000          <1> mov [es:30h*4], dx
   103 00000097 B80000              <1> mov ax, 0
   104 0000009A 26A3C200            <1> mov [es:30h*4 + 2], ax
   105                              <1> 
   106                              <1> ; Add another interrupt entry
   107                              <1> 
   108 0000009E BA[FF00]            <1> mov dx, int_load_program_by_filename
   109 000000A1 268916C400          <1> mov [es:31h*4], dx
   110 000000A6 B80000              <1> mov ax, 0
   111 000000A9 26A3C600            <1> mov [es:31h*4 + 2], ax
   112                              <1> 
   113                              <1> ; Add another interrupt entry
   114                              <1> 
   115 000000AD BA[DC00]            <1> mov dx, int_list_files_from_file_table
   116 000000B0 268916C800          <1> mov [es:32h*4], dx
   117 000000B5 B80000              <1> mov ax, 0
   118 000000B8 26A3CA00            <1> mov [es:32h*4 + 2], ax
   119                              <1> 
   120                              <1> ; Add another interrupt entry
   121                              <1> 
   122 000000BC BA[6D02]            <1> mov dx, int_shutdown
   123 000000BF 268916CC00          <1> mov [es:33h*4], dx
   124 000000C4 B80000              <1> mov ax, 0
   125 000000C7 26A3CE00            <1> mov [es:33h*4 + 2], ax
   126                              <1> 
   127                              <1> 
   128                              <1> ; Add another interrupt entry
   129                              <1> 
   130 000000CB BA[8C02]            <1> mov dx, int_date
   131 000000CE 268916D000          <1> mov [es:34h*4], dx
   132 000000D3 B80000              <1> mov ax, 0
   133 000000D6 26A3D200            <1> mov [es:34h*4 + 2], ax
   134                              <1> 
   135 000000DA 61                  <1> popa
   136                              <1> 
   137 000000DB C3                  <1> ret
   138                              <1> 
   139                              <1> ;-----------------------------------------------------------------
   140                              <1> ;Prints each file name from the file table located at 0x9e00
   141                              <1> 
   142                              <1> int_list_files_from_file_table:
   143                              <1> 
   144 000000DC 60                  <1> pusha
   145                              <1> 	
   146 000000DD B9019E              <1> 	mov cx, 0x9e01
   147 000000E0 BA0000              <1> 	mov dx, 0
   148                              <1> _loop___:
   149 000000E3 83FA20              <1> 	cmp dx, 20h
   150 000000E6 7415                <1> 	je _exit____ ; Exit loop because there are not more FILE structure entries
   151 000000E8 89CE                <1> 	mov si, cx
   152 000000EA 8A04                <1> 	mov al, byte[si]
   153 000000EC 3C00                <1> 	cmp al, 0
   154 000000EE 740D                <1> 	je _exit____ ; Exit if null string is found
   155 000000F0 89C8                <1> 	mov ax, cx
   156 000000F2 CD21                <1> 	int 21h ; Print filename
   157 000000F4 CD23                <1> 	int 23h ; Print new line
   158 000000F6 81C10002            <1> 	add cx, 0x200
   159 000000FA 42                  <1> 	inc dx
   160 000000FB EBE6                <1> 	jmp _loop___
   161                              <1> 
   162                              <1> _exit____:	
   163                              <1> 
   164 000000FD 61                  <1> popa 
   165                              <1> 
   166 000000FE CF                  <1> iret
   167                              <1> 
   168                              <1> ;-----------------------------------------------------------------
   169                              <1> ; Loads Program into memory. Using the filename of the program.
   170                              <1> ; AX=Contains starting address of null-terminated string
   171                              <1> ;
   172                              <1> int_load_program_by_filename:
   173                              <1> 
   174 000000FF 60                  <1> pusha
   175                              <1> 
   176 00000100 B9019E              <1> 	mov cx, 0x9e01
   177 00000103 BA0000              <1> 	mov dx, 0
   178                              <1> _loop__:
   179 00000106 83FA0A              <1> 	cmp dx, 10
   180 00000109 7416                <1> 	je no_program_found ; Exit loop because there are no more FILE structure entries in the file table
   181 0000010B 89CE                <1> 	mov si, cx
   182 0000010D 803C00              <1> 	cmp byte[si], 0
   183 00000110 740F                <1> 	je no_program_found ; Exit if null string is found
   184 00000112 89CB                <1> 	mov bx, cx ; bx <- cx
   185 00000114 CD30                <1> 	int 30h
   186 00000116 09D2                <1> 	or dx, dx
   187 00000118 7411                <1> 	jz found_program ; If strings match then jump to found_program and start executing the program from memory
   188 0000011A 81C10002            <1> 	add cx, 0x200
   189 0000011E 42                  <1> 	inc dx
   190 0000011F EBE5                <1> 	jmp _loop__
   191                              <1> 	
   192                              <1> no_program_found:
   193                              <1> 
   194 00000121 B8[7106]            <1> 	mov ax, invalid_cmd
   195 00000124 BB0F00              <1> 	mov bx, 000fh
   196 00000127 CD21                <1> 	int 21h ; Print invalid command message
   197                              <1> 
   198 00000129 EB2C                <1> jmp _exit___
   199                              <1> 	
   200                              <1> found_program:
   201 0000012B 83C10D              <1> 	add cx, 13
   202 0000012E 89CE                <1> 	mov si, cx
   203 00000130 803C00              <1> 	cmp byte[si], 0
   204 00000133 7407                <1> 	je exec ; if al == 0 then file is program needs to be executed
   205                              <1> 	
   206 00000135 41                  <1> 	inc cx
   207 00000136 89C8                <1> 	mov ax, cx
   208 00000138 CD21                <1> 	int 21h
   209                              <1> 	
   210 0000013A EB1B                <1> 	jmp _exit___
   211                              <1> 	
   212                              <1> exec:
   213                              <1> 	copy_prog_in_mem: ; Copies program into 0x9999 because that is where all programs are loaded and executed
   214 0000013C 41                  <1> 			inc cx
   215 0000013D 89CB                <1> 			mov bx, cx ; bx <- cx because cx cannot be used for this operation
   216 0000013F BF9999              <1> 			mov di, 0x9999 ; Destination index is 0x9999 because that is where the program will be loaded
   217 00000142 BA0000              <1> 			mov dx, 0 ; our counter
   218                              <1> 			looop:
   219 00000145 81FAF101            <1> 			cmp dx, 497 ; 497 because 497 is the maximum number of bytes a program can be. Remember each file table entry occupies 512 bytes
   220 00000149 7409                <1> 			je _call ; if dx = 497 then the program has been fully copied to the region in memory where it will be executed
   221 0000014B 8B37                <1> 			mov  si, [bx] ; copy contents at address bx into source index
   222 0000014D 8935                <1> 			mov [di], si ; Move contents at source index and store it into the memory address at destination index
   223 0000014F 42                  <1> 			inc dx ; increment dx
   224 00000150 47                  <1> 			inc di ; increment destination index
   225 00000151 43                  <1> 			inc bx ; increment bx
   226 00000152 EBF1                <1> 			jmp looop
   227                              <1> 	_call:
   228 00000154 E8(9999)            <1> 			call 0x9999 
   229                              <1> _exit___:
   230                              <1> 	
   231 00000157 61                  <1> popa
   232                              <1> 
   233                              <1> 
   234 00000158 CF                  <1> iret
   235                              <1> 
   236                              <1> ;-----------------------------------------------------------------
   237                              <1> ; Compares two strings
   238                              <1> ; AX=Address of String1 BX=Address of String2 
   239                              <1> ; Returns DX=0 equal any other value means not equal
   240                              <1> int_string_compare:
   241                              <1> 
   242 00000159 51                  <1> push cx ; save cx
   243                              <1> 
   244 0000015A CD25                <1> int 25h ; Get String Length of String1
   245 0000015C 89CA                <1> mov dx, cx
   246 0000015E 50                  <1> push ax ; save ax
   247 0000015F 89D8                <1> mov ax, bx
   248 00000161 CD25                <1> int 25h
   249 00000163 58                  <1> pop ax
   250 00000164 39CA                <1> cmp dx, cx
   251 00000166 7400                <1> je doit ; dx == cx
   252                              <1> 
   253                              <1> doit:
   254 00000168 89C6                <1> 	mov si, ax
   255 0000016A 89DF                <1> 	mov di, bx
   256 0000016C F3A6                <1> 	rep cmpsb
   257 0000016E 7405                <1> 	je identical
   258                              <1> 
   259 00000170 BA0100              <1> 	mov dx, 1
   260 00000173 EB03                <1> 	jmp finish_it
   261                              <1> identical:
   262 00000175 BA0000              <1> 	mov dx, 0
   263                              <1> finish_it:
   264                              <1> 
   265 00000178 59                  <1> pop cx ; restore cx
   266                              <1> 
   267 00000179 CF                  <1> iret
   268                              <1> 
   269                              <1> ;-----------------------------------------------------------------
   270                              <1> ; Checks To See If An Existing FILE structure exists on a specific sector on the disk
   271                              <1> ; Params: AX = Sector To Check If FILE 
   272                              <1> ; Returns The Status In AX. If AX is zero there is an existing FILE structure currently on the disk.
   273                              <1> ; Any other value would mean it is safe to write a FILE structure at that sector
   274                              <1> int_check_file_struct:
   275                              <1> 
   276 0000017A 51                  <1> push cx
   277 0000017B 06                  <1> push es
   278 0000017C 52                  <1> push dx
   279 0000017D 53                  <1> push bx
   280                              <1> 
   281 0000017E 89C1                <1> mov cx, ax    ; Sector ax
   282 00000180 31C0                <1> xor ax, ax
   283 00000182 8EC0                <1> mov es, ax    ; ES <- 0
   284 00000184 BA8000              <1> mov dx, 0080h ; DH = 0 (head), drive = 80h (0th hard disk)
   285 00000187 BB0020              <1> mov bx, 2000h ; segment offset of the buffer
   286 0000018A B80102              <1> mov ax, 0201h ; AH = 02 (disk read), AL = 01 (number of sectors to read)
   287 0000018D CD13                <1> int 13h
   288                              <1> 
   289 0000018F 8B0F                <1> mov cx, [bx]
   290 00000191 83F969              <1> cmp cx, 0x69
   291 00000194 7405                <1> je file_exists
   292                              <1> 
   293 00000196 B80100              <1> mov ax, 1
   294                              <1> 
   295 00000199 EB02                <1> jmp __exit ; File doesnt exist
   296                              <1> 
   297                              <1> file_exists:
   298                              <1> 
   299 0000019B 31C0                <1> xor ax, ax
   300                              <1> 
   301                              <1> __exit:
   302                              <1> 
   303                              <1> 
   304 0000019D 5B                  <1> pop bx
   305 0000019E 5A                  <1> pop dx
   306 0000019F 07                  <1> pop es
   307 000001A0 59                  <1> pop cx
   308                              <1> 
   309 000001A1 CF                  <1> iret
   310                              <1> 
   311                              <1> ;-----------------------------------------------------------------
   312                              <1> ; Writes A FILE structure on the disk. 
   313                              <1> ; Params: BX=Starting Address of FILE structure CX=Sector To Write
   314                              <1> ; Returns AX= -1 if failed to write 
   315                              <1> int_write_file_struct:
   316                              <1> 
   317 000001A2 60                  <1> pusha
   318                              <1> 
   319 000001A3 89D8                <1> 	mov ax, bx
   320 000001A5 CD28                <1> 	int 28h
   321 000001A7 09C0                <1> 	or ax, ax
   322 000001A9 740E                <1> 	jz _error_
   323                              <1> 	
   324 000001AB 31C0                <1> 	xor ax, ax
   325 000001AD 8EC0                <1> 	mov es, ax    ; ES <- 0
   326 000001AF BA8000              <1> 	mov dx, 0080h ; DH = 0 (head), drive = 80h (0th hard disk)
   327 000001B2 B80103              <1> 	mov ax, 0301h ; AH = 03 (disk write), AL = 01 (number of sectors to write)
   328 000001B5 CD13                <1> 	int 13h
   329                              <1> 	
   330 000001B7 EB03                <1> 	jmp _____exit
   331                              <1> 	
   332                              <1> _error_:
   333                              <1> 
   334 000001B9 B8FFFF              <1> 	mov ax, -1
   335                              <1> 
   336                              <1> _____exit:
   337                              <1> 	
   338 000001BC 61                  <1> popa
   339                              <1> 
   340 000001BD CF                  <1> iret 
   341                              <1> 
   342                              <1> ;-----------------------------------------------------------------
   343                              <1> 
   344                              <1> int_clear_screen:
   345                              <1> 
   346 000001BE 60                  <1> pusha
   347 000001BF B400                <1> 		mov ah, 0
   348 000001C1 B003                <1> 		mov al, 3h
   349 000001C3 CD10                <1> 		int 10h
   350                              <1> 
   351 000001C5 61                  <1> popa
   352                              <1> 
   353 000001C6 CF                  <1> iret
   354                              <1> 
   355                              <1> ;-----------------------------------------------------------------
   356                              <1> 
   357                              <1> ;Converts an integer into a string
   358                              <1> ;Params: ax has the integer value, bx has the pointer to the string buffer
   359                              <1> ;Returns nothing
   360                              <1> ;This is an ISR
   361                              <1> 
   362                              <1> int_integer_to_string:
   363                              <1> 
   364 000001C7 52                  <1>    push dx
   365 000001C8 51                  <1>    push cx
   366 000001C9 53                  <1>    push bx
   367 000001CA 50                  <1>    push ax
   368                              <1>    
   369 000001CB 89DF                <1>    mov di, bx
   370                              <1>    
   371 000001CD BB0A00              <1>    mov bx, 10               ; base of the decimal system
   372 000001D0 31C9                <1>    xor cx, cx               ; number of digits generated
   373                              <1> os_int_to_string_next_divide:
   374 000001D2 31D2                <1>    xor dx, dx               ; RAX extended to (RDX,RAX)
   375 000001D4 F7F3                <1>    div bx                  ; divide by the number-base
   376 000001D6 52                  <1>    push dx               ; save remainder on the stack
   377 000001D7 41                  <1>    inc cx                  ; and count this remainder
   378 000001D8 83F800              <1>    cmp ax, 0               ; was the quotient zero?
   379 000001DB 75F5                <1>    jne os_int_to_string_next_divide      ; no, do another division
   380                              <1> 
   381                              <1> os_int_to_string_next_digit:
   382 000001DD 58                  <1>    pop ax                  ; else pop recent remainder
   383 000001DE 0430                <1>    add al, '0'               ; and convert to a numeral
   384 000001E0 AA                  <1>    stosb                  ; store to memory-buffer
   385 000001E1 E2FA                <1>    loop os_int_to_string_next_digit      ; again for other remainders
   386 000001E3 30C0                <1>    xor al, al
   387 000001E5 AA                  <1>    stosb                  ; Store the null terminator at the end of the string
   388                              <1> 
   389 000001E6 58                  <1>    pop ax
   390 000001E7 5B                  <1>    pop bx
   391 000001E8 59                  <1>    pop cx
   392 000001E9 5A                  <1>    pop dx
   393                              <1>    
   394 000001EA CF                  <1>    iret
   395                              <1>    
   396                              <1>    
   397                              <1>    
   398                              <1> ; -----------------------------------------------------------------------------
   399                              <1> 
   400                              <1> ;Computes String (Null Terminated) Length
   401                              <1> ;Params: Starting Address Stored In AX
   402                              <1> ;Returns Length  At CX
   403                              <1> ;This is an ISR
   404                              <1> int_string_length:
   405                              <1> 
   406 000001EB 50                  <1> push ax ; Save
   407 000001EC 89C6                <1> 	mov si, ax
   408 000001EE B90000              <1> 	mov cx, 0
   409                              <1> 	loopy:
   410                              <1> 	
   411 000001F1 AC                  <1> 			lodsb
   412 000001F2 08C0                <1> 			or al, al
   413 000001F4 7403                <1> 			jz exity
   414 000001F6 41                  <1> 			inc cx
   415 000001F7 EBF8                <1> 			jmp loopy
   416                              <1> 	exity:
   417 000001F9 58                  <1> pop ax ; Restore
   418                              <1> 
   419 000001FA CF                  <1> iret
   420                              <1> 
   421                              <1> ;----------------------------------------------------------------------------------
   422                              <1> 
   423                              <1> ; Fills the buffer with zeroes.
   424                              <1> ; Params: Starting Address of Buffer Stored In AX, BX Contains String Length
   425                              <1> ; This is a ISR no direct invoking
   426                              <1> 
   427                              <1> int_zero_buffer:
   428                              <1> 
   429 000001FB 60                  <1> pusha
   430                              <1> 
   431 000001FC 89C7                <1> 	mov di, ax
   432 000001FE B90000              <1>     mov cx, 0
   433                              <1> 	
   434                              <1> 	l:
   435 00000201 B000                <1> 	mov al, 0
   436 00000203 AA                  <1> 	stosb
   437 00000204 39D9                <1> 	cmp cx, bx
   438 00000206 7403                <1> 	je e ; if cx == bx goto e
   439 00000208 41                  <1> 	inc cx ; cx++
   440 00000209 EBF6                <1> 	jmp l ; Go back to the beginning of the loop
   441                              <1> 	
   442                              <1> 	e:
   443                              <1> 
   444 0000020B 61                  <1> popa
   445                              <1> 
   446 0000020C CF                  <1> iret
   447                              <1> 
   448                              <1> ;---------------------------------------------------------------------------------------------------------
   449                              <1> 
   450                              <1> ; Reads Each Character Until Enter Has Been Pressed. This ISR Can ECHO each Character
   451                              <1> ; Params: AX Starting Address Of String
   452                              <1> ; This is a ISR no direct invoking
   453                              <1> int_block_input_echo:
   454                              <1> 
   455 0000020D 60                  <1> 	pusha
   456                              <1> 	
   457 0000020E 89DF                <1> 	mov di, bx
   458 00000210 B90000              <1> 	mov cx, 0
   459                              <1> 	
   460                              <1> 	_again_:
   461                              <1> 
   462 00000213 83F90C              <1> 	cmp cx, 12 ; Prompt cannot accept more than 12 characters
   463 00000216 7425                <1> 	je _max_reached ; We jump to end if cx equals to 12
   464                              <1> 	
   465 00000218 B400                <1> 	mov ah, 0
   466 0000021A CD16                <1> 	int 0x16
   467 0000021C 3C08                <1> 	cmp al, 0x8
   468 0000021E 7505                <1> 	jne print
   469 00000220 83F900              <1> 	cmp cx, 0
   470 00000223 74EE                <1> 	je _again_ ; Ignore print backspace if cursor is already at the beginning
   471                              <1> print:
   472 00000225 B40E                <1> 	mov ah, 0Eh ; ah = 0x0e
   473 00000227 CD10                <1> 	int 0x10 ; print character
   474 00000229 3C08                <1> 	cmp al, 0x8 ; compare al with backspace
   475 0000022B 7408                <1> 	je _ignore ; If backspace we ignore it and avoid adding into the buffer.
   476 0000022D 3C0D                <1> 	cmp al, 0xD ; compare with line feed
   477 0000022F 7412                <1> 	je _end_ ; if al='\r' break from loop
   478 00000231 AA                  <1> 	stosb ; Store Character Byte At AL Into [ES:DI] Then INCREMENTS DI
   479 00000232 41                  <1> 	inc cx ; cx++
   480 00000233 EBDE                <1> 	jmp _again_ ; else go back to the beginning of the loop
   481                              <1> 	_ignore: 
   482 00000235 49                  <1> 	dec cx ; cx-- because we pressed backspace
   483 00000236 39DF                <1> 	cmp di, bx
   484 00000238 74D9                <1> 	je _again_ ; if (di == buffer) we do not want to decrement di 
   485 0000023A 4F                  <1> 	dec di
   486 0000023B EBD6                <1> 	jmp _again_ ; else go back to the beginning of the loop
   487                              <1> 	
   488                              <1> 
   489                              <1> 	
   490                              <1> 	_max_reached:
   491                              <1> 	
   492 0000023D B40E                <1> 	mov ah, 0Eh ; ah = 0x0e
   493 0000023F B00D                <1> 	mov al, 0xD
   494 00000241 CD10                <1> 	int 0x10 ; print character
   495                              <1> 	
   496                              <1> 	_end_:	
   497                              <1> 	
   498 00000243 B000                <1> 	mov al, 0
   499 00000245 AA                  <1> 	stosb
   500                              <1> 	
   501 00000246 B40E                <1>     mov ah, 0Eh
   502 00000248 B00A                <1> 	mov al, 10
   503 0000024A CD10                <1> 	int 0x10 ; Print New Line
   504                              <1> 	 
   505 0000024C 61                  <1> 	popa
   506                              <1> 
   507 0000024D CF                  <1> iret 
   508                              <1> 
   509                              <1> ;--------------------------------------------------------------------------------------------------------------------------
   510                              <1> 
   511                              <1> ;Prints a single new line character
   512                              <1> ; This is a ISR
   513                              <1> int_print_newline:
   514                              <1> 
   515 0000024E 60                  <1> pusha
   516                              <1> 
   517 0000024F B40E                <1> 		mov ah, 0Eh
   518 00000251 B00D                <1> 		mov al, 13
   519 00000253 CD10                <1> 		int 0x10 ; Print New Line
   520                              <1> 
   521 00000255 B40E                <1> 		mov ah, 0Eh
   522 00000257 B00A                <1> 		mov al, 10
   523 00000259 CD10                <1> 		int 0x10 ; Print New Line
   524                              <1> 		
   525 0000025B 61                  <1> popa
   526                              <1> 
   527 0000025C CF                  <1> iret
   528                              <1> 
   529                              <1> ; Prints a null terminated string on the screen
   530                              <1> ; This is ISR (Interrupt Service Routine)
   531                              <1> int_print:
   532 0000025D 60                  <1> 	pusha ; Store all working registers on the stack!
   533 0000025E 89C6                <1> 	mov si, ax
   534                              <1> 
   535                              <1> 	.loop:
   536 00000260 AC                  <1> 			lodsb
   537 00000261 08C0                <1> 			or al, al
   538 00000263 7406                <1> 			jz .endloop ; If character is a null character aka 0 then end the loop			
   539 00000265 B40E                <1> 			mov ah, 0Eh ; ah = 0x0e
   540 00000267 CD10                <1> 			int 0x10 ; print character
   541 00000269 EBF5                <1> 			jmp .loop ; Go back to the beginning of the loop
   542                              <1> 	.endloop:
   543 0000026B 61                  <1> 	popa ; Pop all the saved registers on the stack and restore them!
   544 0000026C CF                  <1> iret ; Return from interrupt
   545                              <1> 
   546                              <1> ;------------------------------------------------------------------------------------------------------
   547                              <1> 
   548                              <1> ; ISR to Shutdown machine
   549                              <1> 
   550                              <1> int_shutdown:
   551                              <1> 
   552 0000026D 60                  <1> pusha ; Save regs
   553                              <1> 
   554                              <1> ;Connect to APM API
   555 0000026E B8B514              <1> mov     ax,5301
   556 00000271 31DB                <1> xor     bx,bx
   557 00000273 CD0F                <1> int     15
   558                              <1> 
   559                              <1> ;Try to set APM version (to 1.2)
   560 00000275 B80E53              <1> mov     ax, 530eh
   561 00000278 31DB                <1> xor     bx,bx
   562 0000027A B90201              <1> mov     cx,0102h
   563 0000027D CD15                <1> int     15h
   564                              <1> 
   565                              <1> ;Turn off the system
   566 0000027F B80753              <1> mov     ax,5307h
   567 00000282 BB0100              <1> mov     bx,0001h
   568 00000285 B90300              <1> mov     cx,0003h
   569 00000288 CD15                <1> int     15h
   570                              <1> 
   571 0000028A 61                  <1> popa ; Restore regs
   572                              <1> 
   573 0000028B CF                  <1> iret
   574                              <1> 
   575                              <1> ;------------------------------------------------------------------------------------------------------
   576                              <1> 
   577                              <1> int_date:
   578                              <1> 
   579 0000028C 60                  <1> pusha
   580                              <1> 
   581 0000028D 31C0                <1> xor ax, ax
   582 0000028F B404                <1> mov ah, 04h
   583 00000291 CD1A                <1> int 1ah
   584                              <1> 
   585 00000293 7232                <1> jc done
   586                              <1> 
   587 00000295 B400                <1> mov ah, 00
   588 00000297 88F0                <1> mov al, dh
   589                              <1> 
   590 00000299 CD26                <1> int 26h ; Convert month to string
   591                              <1> 
   592 0000029B 89D8                <1> mov ax, bx
   593 0000029D BB0100              <1> mov bx, 01h
   594                              <1> 
   595 000002A0 CD21                <1> int 21h ; Print month
   596                              <1> 
   597 000002A2 B40E                <1> mov ah, 0Eh
   598 000002A4 B02F                <1> mov al, '/'
   599 000002A6 CD10                <1> int 0x10 ; Print Date Separator
   600                              <1> 
   601 000002A8 B400                <1> mov ah, 00 
   602 000002AA 88D0                <1> mov al, dl
   603                              <1> 
   604 000002AC CD26                <1> int 26h ; Convert day to string
   605                              <1> 
   606 000002AE 89D8                <1> mov ax, bx
   607 000002B0 BB0100              <1> mov bx, 01h
   608                              <1> 
   609 000002B3 CD21                <1> int 21h ; Print day
   610                              <1> 
   611 000002B5 B40E                <1> mov ah, 0Eh
   612 000002B7 B02F                <1> mov al, '/'
   613 000002B9 CD10                <1> int 0x10 ; Print Date Separator
   614                              <1> 
   615 000002BB 89C8                <1> mov ax, cx
   616                              <1> 
   617 000002BD CD26                <1> int 26h ; Convert year to string
   618                              <1> 
   619 000002BF 89D8                <1> mov ax, bx
   620 000002C1 BB0100              <1> mov bx, 01h
   621                              <1> 
   622 000002C4 CD21                <1> int 21h ; Print year
   623                              <1> 
   624                              <1> 
   625 000002C6 61                  <1> popa
   626                              <1> 
   627                              <1> done:
   628                              <1> 
   629 000002C7 CF                  <1> iret
   630                              <1> 
   631                                  
   632                                  
   633                                  
   634                                  main:
   635                                  
   636 000002C8 E838FD                  call init_int
   637                                  
   638 000002CB 31C0                    xor ax, ax ; make it zero
   639 000002CD 8ED8                    mov ds, ax ; Data segment is zero
   640 000002CF 8EC0                    mov es, ax
   641                                  
   642                                  
   643                                  
   644                                  ; Clear Screen
   645                                  
   646 000002D1 CD27                    int 27h
   647                                  
   648                                  
   649                                  ; Print Startup Message
   650                                  
   651 000002D3 B8[A003]                mov ax, welcome_msg ; Store pointer to string AX register
   652 000002D6 BB[D506]                mov bx, current_color ; Store current color in BX
   653 000002D9 CD21                    int 21h ; Call print ISR
   654                                  
   655                                  
   656                                  hang:
   657                                  	
   658                                  
   659 000002DB E8B900                  	call zero_buffer
   660                                  	
   661                                  	; Print Desired Message
   662                                  
   663 000002DE B8[5204]                	mov ax, cli_msg
   664 000002E1 BB[D506]                	mov bx, current_color
   665                                  
   666 000002E4 CD21                    	int 21h ; print ax=msg bl=blue
   667                                  
   668                                  	; Get Input
   669 000002E6 BB[D606]                	mov bx, buffer
   670 000002E9 CD22                    	int 22h ; Read From Keyboard  And Store String In Buffer
   671                                  	
   672 000002EB 803F00                  	cmp byte[bx], 0 ; Empty command are ignored therefore
   673                                  	
   674 000002EE 74EB                    	je hang
   675                                  	
   676 000002F0 BB[D606]                	mov bx, buffer
   677 000002F3 B8[5306]                	mov ax, internal_command_A
   678                                  	
   679 000002F6 CD30                    	int 30h ; string compare buffer and commandA
   680                                  	
   681 000002F8 83FA00                  	cmp dx, 0 
   682                                  	
   683 000002FB 0F848900                	je help_command ;if (buffer == command) goto help_command
   684                                  	
   685 000002FF BB[D606]                	mov bx, buffer
   686 00000302 B8[5806]                	mov ax, internal_command_B
   687                                  	
   688 00000305 CD30                    	int 30h ; string compare buffer and commandB
   689                                  	
   690 00000307 83FA00                  	cmp dx, 0 
   691                                  	
   692 0000030A 745D                    	je clear_command
   693                                  	
   694 0000030C BB[D606]                	mov bx, buffer
   695 0000030F B8[5E06]                	mov ax, internal_command_C
   696                                  	
   697 00000312 CD30                    	int 30h ; string compare buffer and commandC
   698                                  	
   699 00000314 83FA00                  	cmp dx, 0 
   700                                  	
   701 00000317 741C                    	je list_command
   702                                  	
   703                                  	
   704 00000319 BB[D606]                	mov bx, buffer
   705 0000031C B8[6C06]                	mov ax, internal_command_E
   706                                  	
   707 0000031F CD30                    	int 30h ; string compare buffer and commandE
   708                                  	
   709 00000321 83FA00                  	cmp dx, 0 
   710                                  	
   711 00000324 7459                    	je date_command
   712                                  	
   713                                  	
   714 00000326 BB[D606]                	mov bx, buffer
   715 00000329 B8[6306]                	mov ax, internal_command_D
   716                                  	
   717 0000032C CD30                    	int 30h
   718                                  	
   719 0000032E 83FA00                  	cmp dx, 0
   720                                  	
   721 00000331 743B                    	je shutdown_command
   722                                  	
   723 00000333 EB10                    	jmp external_command
   724                                  	
   725                                  	
   726                                  list_command:
   727                                  
   728 00000335 CD23                    		int 23h ; Print newline
   729                                  
   730 00000337 CD32                    		int 32h ; List files from file table
   731                                  		
   732 00000339 B8[0404]                		mov ax, system_file
   733 0000033C BB[D506]                		mov bx, current_color
   734 0000033F CD21                    		int 21h
   735 00000341 CD23                    		int 23h
   736                                  		
   737 00000343 EB96                    		jmp hang
   738                                  	
   739                                  external_command:
   740                                  
   741                                  
   742 00000345 BB[D606]                		mov bx, buffer
   743 00000348 B8[0404]                		mov ax, system_file
   744 0000034B CD30                    		int 30h
   745                                  
   746                                  		
   747 0000034D 83FA00                  		cmp dx, 00h
   748                                  		
   749 00000350 750B                    		jne not_a_system_file
   750                                  		
   751 00000352 B8[0F04]                		mov ax, error_system_file
   752 00000355 BB[D506]                		mov bx, current_color
   753 00000358 CD21                    		int 21h
   754                                  		
   755 0000035A E97EFF                  		jmp hang
   756                                  		
   757                                  not_a_system_file:
   758                                  		
   759 0000035D CD23                    		int 23h ; new line
   760 0000035F B8[D606]                		mov ax, buffer
   761 00000362 CD31                    		int 31h ; Check if buffer contains a valid filename and load and execute external command.
   762 00000364 CD23                    		int 23h ; new line
   763                                  		
   764 00000366 E972FF                  		jmp hang
   765                                  		
   766                                  
   767                                  clear_command:
   768                                  
   769                                  		; Clear Screen
   770                                  
   771 00000369 CD27                    		int 27h
   772                                  		
   773 0000036B E96DFF                  		jmp hang
   774                                  	
   775                                  shutdown_command:
   776                                  
   777 0000036E CD33                    	int 33h
   778 00000370 CD23                    	int 23h
   779 00000372 B8[9606]                	mov ax, poweroff_failed
   780 00000375 BB[D506]                	mov bx, current_color
   781 00000378 CD21                    	int 21h
   782 0000037A CD23                        int 23h
   783                                  	
   784 0000037C E95CFF                  	jmp hang
   785                                  	
   786                                  	
   787                                  date_command:
   788                                  
   789 0000037F CD23                    	int 23h
   790                                  	
   791                                  	
   792                                  	
   793 00000381 CD34                    	int 34h ; Call date printing ISR
   794                                  	
   795                                  	
   796 00000383 CD23                    	int 23h
   797                                  
   798                                  
   799 00000385 E953FF                  	jmp hang
   800                                  	
   801                                  help_command:
   802                                  
   803 00000388 CD23                    		int 23h ; Print newline
   804                                  
   805 0000038A B8[6004]                		mov ax, help_msg
   806 0000038D BB[D506]                		mov bx, current_color
   807 00000390 CD21                    		int 21h ; Print help string
   808                                  
   809 00000392 CD23                    		int 23h ; Print newline
   810                                  		
   811 00000394 E944FF                  		jmp hang
   812                                  		
   813                                  		
   814                                  zero_buffer:
   815                                  
   816 00000397 B8[D606]                	mov ax, buffer
   817 0000039A BB0C00                  	mov bx, 12
   818 0000039D CD24                    	int 24h	
   819                                  
   820 0000039F C3                      ret 
   821                                  		
   822                                  
   823                                  		
   824 000003A0 4D6F6E737465724F53-     welcome_msg: db 'MonsterOS Version 1.0', 13, 10, 'Copyright (C) 2014 Daniel Lopez. Licensed Under The Simplified BSD License', 13, 10, 0
   825 000003A9 2056657273696F6E20-
   826 000003B2 312E300D0A436F7079-
   827 000003BB 726967687420284329-
   828 000003C4 20323031342044616E-
   829 000003CD 69656C204C6F70657A-
   830 000003D6 2E204C6963656E7365-
   831 000003DF 6420556E6465722054-
   832 000003E8 68652053696D706C69-
   833 000003F1 666965642042534420-
   834 000003FA 4C6963656E73650D0A-
   835 00000403 00                 
   836 00000404 6B65726E656C2E7379-     system_file db 'kernel.sys', 0
   837 0000040D 7300               
   838 0000040F 0D0A4572726F723A20-     error_system_file: db 13, 10, 'Error: kernel.sys is a system file cannot be executed or read!', 13, 10, 0
   839 00000418 6B65726E656C2E7379-
   840 00000421 732069732061207379-
   841 0000042A 7374656D2066696C65-
   842 00000433 2063616E6E6F742062-
   843 0000043C 652065786563757465-
   844 00000445 64206F722072656164-
   845 0000044E 210D0A00           
   846 00000452 0D0A4D6F6E73746572-     cli_msg: db 13, 10, 'MonsterOS> ', 0
   847 0000045B 4F533E2000         
   848 00000460 57656C636F6D652074-     help_msg: db 'Welcome to the MonsterOS shell prompt.', 13, 10, 13, 10, 'MonsterOS shell prompt contains only two internal commands: help, clear, and list.', 13, 10, 'This means that MonsterOS treats everything else 
   849 00000469 6F20746865204D6F6E-
   850 00000472 737465724F53207368-
   851 0000047B 656C6C2070726F6D70-
   852 00000484 742E0D0A0D0A4D6F6E-
   853 0000048D 737465724F53207368-
   854 00000496 656C6C2070726F6D70-
   855 0000049F 7420636F6E7461696E-
   856 000004A8 73206F6E6C79207477-
   857 000004B1 6F20696E7465726E61-
   858 000004BA 6C20636F6D6D616E64-
   859 000004C3 733A2068656C702C20-
   860 000004CC 636C6561722C20616E-
   861 000004D5 64206C6973742E0D0A-
   862 000004DE 54686973206D65616E-
   863 000004E7 732074686174204D6F-
   864 000004F0 6E737465724F532074-
   865 000004F9 726561747320657665-
   866 00000502 72797468696E672065-
   867 0000050B 6C7365207468617420-
   868 00000514 6973206E6F74207468-
   869 0000051D 652068656C702F636C-
   870 00000526 65617220636F6D6D61-
   871 0000052F 6E6420617320616E20-
   872 00000538 65787465726E616C20-
   873 00000541 636F6D6D616E642E0D-
   874 0000054A 0A416E206578746572-
   875 00000553 6E616C20636F6D6D61-
   876 0000055C 6E6420697320626173-
   877 00000565 6963616C6C79206120-
   878 0000056E 66696C656E616D6520-
   879 00000577 6F6620612066696C65-
   880 00000580 2073746F726564206F-
   881 00000589 6E2074686520646973-
   882 00000592 6B2E0A0D4966207468-
   883 0000059B 652066696C65206973-
   884 000005A4 206C6F636174656420-
   885 000005AD 6F6E20746865206469-
   886 000005B6 736B20697420697320-
   887 000005BF 657865637574656420-
   888 000005C8 696620697420697320-
   889 000005D1 612070726F6772616D-
   890 000005DA 3B20656C7365206974-
   891 000005E3 206973207472656174-
   892 000005EC 656420612074657874-
   893 000005F5 2066696C6520616E64-
   894 000005FE 2069747320636F6E74-
   895 00000607 656E74732061726520-
   896 00000610 646973706C61796564-
   897 00000619 2E0D0A4966206E6F20-
   898 00000622 66696C652069732066-
   899 0000062B 6F756E64207468656E-
   900 00000634 2061206572726F7220-
   901 0000063D 6D6573736167652069-
   902 00000646 7320646973706C6179-
   903 0000064F 65642E00           
   904 00000653 68656C7000              internal_command_A: db 'help', 0
   905 00000658 636C65617200            internal_command_B: db 'clear', 0
   906 0000065E 6C69737400              internal_command_C: db 'list', 0
   907 00000663 706F7765726F666600      internal_command_D: db 'poweroff', 0
   908 0000066C 6461746500              internal_command_E: db 'date', 00
   909 00000671 496E76616C69642049-     invalid_cmd: db 'Invalid Internal / External Command!',0
   910 0000067A 6E7465726E616C202F-
   911 00000683 2045787465726E616C-
   912 0000068C 20436F6D6D616E6421-
   913 00000695 00                 
   914 00000696 4D616368696E652066-     poweroff_failed: db 'Machine failed to shutdown!!!', 13, 10, 'Error: APM May Not Be Supported', 0
   915 0000069F 61696C656420746F20-
   916 000006A8 73687574646F776E21-
   917 000006B1 21210D0A4572726F72-
   918 000006BA 3A2041504D204D6179-
   919 000006C3 204E6F742042652053-
   920 000006CC 7570706F7274656400 
   921 000006D5 01                      current_color: db 001h
   922 000006D6 00<rept>                buffer: times 12 db 0
   923                                  
   924                                  
