     1                                  ; Copyright (c) 2013, Daniel Lopez
     2                                  ;All rights reserved.
     3                                  ;
     4                                  ;Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
     5                                  ;
     6                                  ;Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
     7                                  ;Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
     8                                  ;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICUL
     9                                  
    10                                  ;Kernel
    11                                  
    12                                  [ORG 0x7e00]
    13                                  
    14 00000000 E9D101                  jmp main
    15                                  
    16                                  %include "syscalls.inc"
    17                              <1> ; Copyright (c) 2013, Daniel Lopez
    18                              <1> ;All rights reserved.
    19                              <1> ;
    20                              <1> ;Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    21                              <1> ;
    22                              <1> ;Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    23                              <1> ;Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
    24                              <1> ;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICUL
    25                              <1> 
    26                              <1> 
    27                              <1> 
    28                              <1> ; Initialize Interrupts
    29                              <1> init_int:
    30                              <1> 
    31 00000003 60                  <1> pusha
    32                              <1> 
    33 00000004 31C0                <1> xor ax, ax
    34 00000006 8EC0                <1> mov es, ax ; es = 0
    35                              <1> 
    36                              <1> ; Add the interrupt entry 
    37                              <1> 
    38 00000008 BA[C401]            <1> mov dx, int_print 
    39 0000000B 2689168400          <1> mov [es:21h*4], dx
    40 00000010 B80000              <1> mov ax, 0
    41 00000013 26A38600            <1> mov [es:21h*4 + 2], ax
    42                              <1> 
    43                              <1> ; Add another interrupt entry
    44                              <1> 
    45 00000017 BA[8501]            <1> mov dx, int_block_input_echo 
    46 0000001A 2689168800          <1> mov [es:22h*4], dx
    47 0000001F B80000              <1> mov ax, 0
    48 00000022 26A38A00            <1> mov [es:22h*4 + 2], ax
    49                              <1> 
    50                              <1> ; Add another interrupt entry
    51                              <1> 
    52 00000026 BA[B501]            <1> mov dx, int_print_newline 
    53 00000029 2689168C00          <1> mov [es:23h*4], dx
    54 0000002E B80000              <1> mov ax, 0
    55 00000031 26A38E00            <1> mov [es:23h*4 + 2], ax
    56                              <1> 
    57                              <1> ; Add another interrupt entry
    58                              <1> 
    59 00000035 BA[7301]            <1> mov dx, int_zero_buffer 
    60 00000038 2689169000          <1> mov [es:24h*4], dx
    61 0000003D B80000              <1> mov ax, 0
    62 00000040 26A39200            <1> mov [es:24h*4 + 2], ax
    63                              <1> 
    64                              <1> ; Add another interrupt entry
    65                              <1> 
    66 00000044 BA[6301]            <1> mov dx, int_string_length 
    67 00000047 2689169400          <1> mov [es:25h*4], dx
    68 0000004C B80000              <1> mov ax, 0
    69 0000004F 26A39600            <1> mov [es:25h*4 + 2], ax
    70                              <1> 
    71                              <1> ; Add another interrupt entry
    72                              <1> 
    73 00000053 BA[3F01]            <1> mov dx, int_integer_to_string
    74 00000056 2689169800          <1> mov [es:26h*4], dx
    75 0000005B B80000              <1> mov ax, 0
    76 0000005E 26A39A00            <1> mov [es:26h*4 + 2], ax
    77                              <1> 
    78                              <1> ; Add another interrupt entry
    79                              <1> 
    80 00000062 BA[3601]            <1> mov dx, int_clear_screen
    81 00000065 2689169C00          <1> mov [es:27h*4], dx
    82 0000006A B80000              <1> mov ax, 0
    83 0000006D 26A39E00            <1> mov [es:27h*4 + 2], ax
    84                              <1> 
    85                              <1> ; Add another interrupt entry
    86                              <1> 
    87 00000071 BA[F200]            <1> mov dx, int_check_file_struct
    88 00000074 268916A000          <1> mov [es:28h*4], dx
    89 00000079 B80000              <1> mov ax, 0
    90 0000007C 26A3A200            <1> mov [es:28h*4 + 2], ax
    91                              <1> 
    92                              <1> ; Add another interrupt entry
    93                              <1> 
    94 00000080 BA[1A01]            <1> mov dx, int_write_file_struct
    95 00000083 268916A400          <1> mov [es:29h*4], dx
    96 00000088 B80000              <1> mov ax, 0
    97 0000008B 26A3A600            <1> mov [es:29h*4 + 2], ax
    98                              <1> 
    99                              <1> ; Add another interrupt entry
   100                              <1> 
   101 0000008F BA[D100]            <1> mov dx, int_string_compare
   102 00000092 268916C000          <1> mov [es:30h*4], dx
   103 00000097 B80000              <1> mov ax, 0
   104 0000009A 26A3C200            <1> mov [es:30h*4 + 2], ax
   105                              <1> 
   106                              <1> ; Add another interrupt entry
   107                              <1> 
   108 0000009E BA[AF00]            <1> mov dx, int_load_program_by_filename
   109 000000A1 268916C400          <1> mov [es:31h*4], dx
   110 000000A6 B80000              <1> mov ax, 0
   111 000000A9 26A3C600            <1> mov [es:31h*4 + 2], ax
   112                              <1> 
   113                              <1> 
   114 000000AD 61                  <1> popa
   115                              <1> 
   116 000000AE C3                  <1> ret
   117                              <1> 
   118                              <1> 
   119                              <1> ;-----------------------------------------------------------------
   120                              <1> ; Loads Program into memory. Using the filename of the program.
   121                              <1> ; AX=Contains starting address of null-terminated string
   122                              <1> int_load_program_by_filename:
   123                              <1> 
   124 000000AF 60                  <1> pusha
   125                              <1> 
   126 000000B0 B9019E              <1> 	mov cx, 0x9e01
   127 000000B3 BA0000              <1> 	mov dx, 0
   128                              <1> _loop__:
   129 000000B6 83FA05              <1> 	cmp dx, 5
   130 000000B9 7414                <1> 	je _exit___ ; Exit loop because there are not more FILE structure entries
   131 000000BB 89CB                <1> 	mov bx, cx ; bx <- cx
   132 000000BD CD30                <1> 	int 30h
   133 000000BF 09D2                <1> 	or dx, dx
   134 000000C1 7407                <1> 	jz found_program ; If strings match then jump to found_program and start executing the program from memory
   135 000000C3 81C10002            <1> 	add cx, 0x200
   136 000000C7 42                  <1> 	inc dx
   137 000000C8 EBEC                <1> 	jmp _loop__
   138                              <1> 	
   139                              <1> 
   140                              <1> found_program:
   141                              <1> 
   142 000000CA 83C10B              <1> add cx, 11
   143 000000CD FFD1                <1> call cx
   144                              <1> 
   145                              <1> _exit___:
   146                              <1> 	
   147 000000CF 61                  <1> popa
   148                              <1> 
   149                              <1> 
   150 000000D0 CF                  <1> iret
   151                              <1> 
   152                              <1> ;-----------------------------------------------------------------
   153                              <1> ; Compares two strings
   154                              <1> ; AX=Address of String1 BX=Address of String2 
   155                              <1> ; Returns DX=0 equal any other value means not equal
   156                              <1> int_string_compare:
   157                              <1> 
   158 000000D1 CD25                <1> int 25h ; Get String Length of String1
   159 000000D3 89CA                <1> mov dx, cx
   160 000000D5 50                  <1> push ax ; save ax
   161 000000D6 89D8                <1> mov ax, bx
   162 000000D8 CD25                <1> int 25h
   163 000000DA 58                  <1> pop ax
   164 000000DB 39CA                <1> cmp dx, cx
   165 000000DD 7F02                <1> jg doit ; dx > cx
   166 000000DF 89D1                <1> mov cx, dx
   167                              <1> 
   168                              <1> doit:
   169 000000E1 89C6                <1> 	mov si, ax
   170 000000E3 89DF                <1> 	mov di, bx
   171 000000E5 F3A6                <1> 	rep cmpsb
   172 000000E7 7405                <1> 	je identical
   173                              <1> 
   174 000000E9 BA0100              <1> 	mov dx, 1
   175 000000EC EB03                <1> 	jmp finish_it
   176                              <1> identical:
   177 000000EE BA0000              <1> 	mov dx, 0
   178                              <1> finish_it:
   179                              <1> 
   180 000000F1 CF                  <1> iret
   181                              <1> 
   182                              <1> ;-----------------------------------------------------------------
   183                              <1> ; Checks To See If An Existing FILE structure exists on a specific sector on the disk
   184                              <1> ; Params: AX = Sector To Check If FILE 
   185                              <1> ; Returns The Status In AX. If AX is zero there is an existing FILE structure currently on the disk.
   186                              <1> ; Any other value would mean it is safe to write a FILE structure at that sector
   187                              <1> int_check_file_struct:
   188                              <1> 
   189 000000F2 51                  <1> push cx
   190 000000F3 06                  <1> push es
   191 000000F4 52                  <1> push dx
   192 000000F5 53                  <1> push bx
   193                              <1> 
   194 000000F6 89C1                <1> mov cx, ax    ; Sector ax
   195 000000F8 31C0                <1> xor ax, ax
   196 000000FA 8EC0                <1> mov es, ax    ; ES <- 0
   197 000000FC BA8000              <1> mov dx, 0080h ; DH = 0 (head), drive = 80h (0th hard disk)
   198 000000FF BB0020              <1> mov bx, 2000h ; segment offset of the buffer
   199 00000102 B80102              <1> mov ax, 0201h ; AH = 02 (disk read), AL = 01 (number of sectors to read)
   200 00000105 CD13                <1> int 13h
   201                              <1> 
   202 00000107 8B0F                <1> mov cx, [bx]
   203 00000109 83F969              <1> cmp cx, 0x69
   204 0000010C 7405                <1> je file_exists
   205                              <1> 
   206 0000010E B80100              <1> mov ax, 1
   207                              <1> 
   208 00000111 EB02                <1> jmp __exit ; File doesnt exist
   209                              <1> 
   210                              <1> file_exists:
   211                              <1> 
   212 00000113 31C0                <1> xor ax, ax
   213                              <1> 
   214                              <1> __exit:
   215                              <1> 
   216                              <1> 
   217 00000115 5B                  <1> pop bx
   218 00000116 5A                  <1> pop dx
   219 00000117 07                  <1> pop es
   220 00000118 59                  <1> pop cx
   221                              <1> 
   222 00000119 CF                  <1> iret
   223                              <1> 
   224                              <1> ;-----------------------------------------------------------------
   225                              <1> ; Writes A FILE structure on the disk. 
   226                              <1> ; Params: BX=Starting Address of FILE structure CX=Sector To Write
   227                              <1> ; Returns AX= -1 if failed to write 
   228                              <1> int_write_file_struct:
   229                              <1> 
   230 0000011A 60                  <1> pusha
   231                              <1> 
   232 0000011B 89D8                <1> 	mov ax, bx
   233 0000011D CD28                <1> 	int 28h
   234 0000011F 09C0                <1> 	or ax, ax
   235 00000121 740E                <1> 	jz _error_
   236                              <1> 	
   237 00000123 31C0                <1> 	xor ax, ax
   238 00000125 8EC0                <1> 	mov es, ax    ; ES <- 0
   239 00000127 BA8000              <1> 	mov dx, 0080h ; DH = 0 (head), drive = 80h (0th hard disk)
   240 0000012A B80103              <1> 	mov ax, 0301h ; AH = 03 (disk write), AL = 01 (number of sectors to write)
   241 0000012D CD13                <1> 	int 13h
   242                              <1> 	
   243 0000012F EB03                <1> 	jmp _____exit
   244                              <1> 	
   245                              <1> _error_:
   246                              <1> 
   247 00000131 B8FFFF              <1> 	mov ax, -1
   248                              <1> 
   249                              <1> _____exit:
   250                              <1> 	
   251 00000134 61                  <1> popa
   252                              <1> 
   253 00000135 CF                  <1> iret 
   254                              <1> 
   255                              <1> ;-----------------------------------------------------------------
   256                              <1> 
   257                              <1> int_clear_screen:
   258                              <1> 
   259 00000136 60                  <1> pusha
   260 00000137 B400                <1> 		mov ah, 0
   261 00000139 B003                <1> 		mov al, 3h
   262 0000013B CD10                <1> 		int 10h
   263                              <1> 
   264 0000013D 61                  <1> popa
   265                              <1> 
   266 0000013E CF                  <1> iret
   267                              <1> 
   268                              <1> ;-----------------------------------------------------------------
   269                              <1> 
   270                              <1> ;Converts an integer into a string
   271                              <1> ;Params: ax has the integer value, bx has the pointer to the string buffer
   272                              <1> ;Returns nothing
   273                              <1> ;This is an ISR
   274                              <1> 
   275                              <1> int_integer_to_string:
   276                              <1> 
   277 0000013F 52                  <1>    push dx
   278 00000140 51                  <1>    push cx
   279 00000141 53                  <1>    push bx
   280 00000142 50                  <1>    push ax
   281                              <1>    
   282 00000143 89DF                <1>    mov di, bx
   283                              <1>    
   284 00000145 BB0A00              <1>    mov bx, 10               ; base of the decimal system
   285 00000148 31C9                <1>    xor cx, cx               ; number of digits generated
   286                              <1> os_int_to_string_next_divide:
   287 0000014A 31D2                <1>    xor dx, dx               ; RAX extended to (RDX,RAX)
   288 0000014C F7F3                <1>    div bx                  ; divide by the number-base
   289 0000014E 52                  <1>    push dx               ; save remainder on the stack
   290 0000014F 41                  <1>    inc cx                  ; and count this remainder
   291 00000150 83F800              <1>    cmp ax, 0               ; was the quotient zero?
   292 00000153 75F5                <1>    jne os_int_to_string_next_divide      ; no, do another division
   293                              <1> 
   294                              <1> os_int_to_string_next_digit:
   295 00000155 58                  <1>    pop ax                  ; else pop recent remainder
   296 00000156 0430                <1>    add al, '0'               ; and convert to a numeral
   297 00000158 AA                  <1>    stosb                  ; store to memory-buffer
   298 00000159 E2FA                <1>    loop os_int_to_string_next_digit      ; again for other remainders
   299 0000015B 30C0                <1>    xor al, al
   300 0000015D AA                  <1>    stosb                  ; Store the null terminator at the end of the string
   301                              <1> 
   302 0000015E 58                  <1>    pop ax
   303 0000015F 5B                  <1>    pop bx
   304 00000160 59                  <1>    pop cx
   305 00000161 5A                  <1>    pop dx
   306                              <1>    
   307 00000162 CF                  <1>    iret
   308                              <1>    
   309                              <1>    
   310                              <1>    
   311                              <1> ; -----------------------------------------------------------------------------
   312                              <1> 
   313                              <1> ;Computes String (Null Terminated) Length
   314                              <1> ;Params: Starting Address Stored In AX
   315                              <1> ;Returns Length  At CX
   316                              <1> ;This is an ISR
   317                              <1> int_string_length:
   318                              <1> 
   319 00000163 50                  <1> push ax ; Save
   320 00000164 89C6                <1> 	mov si, ax
   321 00000166 B90000              <1> 	mov cx, 0
   322                              <1> 	loopy:
   323                              <1> 	
   324 00000169 AC                  <1> 			lodsb
   325 0000016A 08C0                <1> 			or al, al
   326 0000016C 7403                <1> 			jz exity
   327 0000016E 41                  <1> 			inc cx
   328 0000016F EBF8                <1> 			jmp loopy
   329                              <1> 	exity:
   330 00000171 58                  <1> pop ax ; Restore
   331                              <1> 
   332 00000172 CF                  <1> iret
   333                              <1> 
   334                              <1> ;----------------------------------------------------------------------------------
   335                              <1> 
   336                              <1> ; Fills the buffer with zeroes.
   337                              <1> ; Params: Starting Address of Buffer Stored In AX, BX Contains String Length
   338                              <1> ; This is a ISR no direct invoking
   339                              <1> 
   340                              <1> int_zero_buffer:
   341                              <1> 
   342 00000173 60                  <1> pusha
   343                              <1> 
   344 00000174 89C7                <1> 	mov di, ax
   345 00000176 B90000              <1>     mov cx, 0
   346                              <1> 	
   347                              <1> 	l:
   348 00000179 B000                <1> 	mov al, 0
   349 0000017B AA                  <1> 	stosb
   350 0000017C 39D9                <1> 	cmp cx, bx
   351 0000017E 7403                <1> 	je e ; if cx == bx goto e
   352 00000180 41                  <1> 	inc cx ; cx++
   353 00000181 EBF6                <1> 	jmp l ; Go back to the beginning of the loop
   354                              <1> 	
   355                              <1> 	e:
   356                              <1> 
   357 00000183 61                  <1> popa
   358                              <1> 
   359 00000184 CF                  <1> iret
   360                              <1> 
   361                              <1> ;---------------------------------------------------------------------------------------------------------
   362                              <1> 
   363                              <1> ; Reads Each Character Until Enter Has Been Pressed. This ISR Can ECHO each Character
   364                              <1> ; Params: AX Starting Address Of String
   365                              <1> ; This is a ISR no direct invoking
   366                              <1> int_block_input_echo:
   367                              <1> 
   368 00000185 60                  <1> 	pusha
   369                              <1> 	
   370 00000186 89DF                <1> 	mov di, bx
   371 00000188 B90000              <1> 	mov cx, 0
   372                              <1> 	
   373                              <1> 	_again_:
   374                              <1> 
   375 0000018B 83F908              <1> 	cmp cx, 8 ; Prompt cannot accept more than 8 characters
   376 0000018E 7414                <1> 	je _max_reached ; We jump to end if cx equals to 8
   377                              <1> 	
   378 00000190 B400                <1> 	mov ah, 0
   379 00000192 CD16                <1> 	int 0x16
   380 00000194 B40E                <1> 	mov ah, 0Eh ; ah = 0x0e
   381 00000196 CD10                <1> 	int 0x10 ; print character
   382 00000198 3C08                <1> 	cmp al, 0x8 ; compare al with backspace
   383 0000019A 7405                <1> 	je _ignore ; If backspace we ignore it and avoid adding into the buffer.
   384 0000019C 3C0D                <1> 	cmp al, 0xD ; compare with line feed
   385 0000019E 740A                <1> 	je _end_ ; if al='\r' break from loop
   386 000001A0 AA                  <1> 	stosb ; Store Character Byte At AL Into [ES:DI] Then INCREMENTS DI
   387                              <1> 	_ignore: 
   388 000001A1 41                  <1> 	inc cx ; cx++
   389 000001A2 EBE7                <1> 	jmp _again_ ; else go back to the beginning of the loop
   390                              <1> 	
   391                              <1> 
   392                              <1> 	
   393                              <1> 	_max_reached:
   394                              <1> 	
   395 000001A4 B40E                <1> 	mov ah, 0Eh ; ah = 0x0e
   396 000001A6 B00D                <1> 	mov al, 0xD
   397 000001A8 CD10                <1> 	int 0x10 ; print character
   398                              <1> 	
   399                              <1> 	_end_:	
   400                              <1> 	
   401 000001AA B000                <1> 	mov al, 0
   402 000001AC AA                  <1> 	stosb
   403                              <1> 	
   404 000001AD B40E                <1>     mov ah, 0Eh
   405 000001AF B00A                <1> 	mov al, 10
   406 000001B1 CD10                <1> 	int 0x10 ; Print New Line
   407                              <1> 	 
   408 000001B3 61                  <1> 	popa
   409                              <1> 
   410 000001B4 CF                  <1> iret 
   411                              <1> 
   412                              <1> ;--------------------------------------------------------------------------------------------------------------------------
   413                              <1> 
   414                              <1> ;Prints a single new line character
   415                              <1> ; This is a ISR
   416                              <1> int_print_newline:
   417                              <1> 
   418 000001B5 60                  <1> pusha
   419                              <1> 
   420 000001B6 B40E                <1> 		mov ah, 0Eh
   421 000001B8 B00D                <1> 		mov al, 13
   422 000001BA CD10                <1> 		int 0x10 ; Print New Line
   423                              <1> 
   424 000001BC B40E                <1> 		mov ah, 0Eh
   425 000001BE B00A                <1> 		mov al, 10
   426 000001C0 CD10                <1> 		int 0x10 ; Print New Line
   427                              <1> 		
   428 000001C2 61                  <1> popa
   429                              <1> 
   430 000001C3 CF                  <1> iret
   431                              <1> 
   432                              <1> ; Prints a null terminated string on the screen
   433                              <1> ; This is ISR (Interrupt Service Routine)
   434                              <1> int_print:
   435 000001C4 60                  <1> 	pusha ; Store all working registers on the stack!
   436 000001C5 89C6                <1> 	mov si, ax
   437                              <1> 
   438                              <1> 	.loop:
   439 000001C7 AC                  <1> 			lodsb
   440 000001C8 08C0                <1> 			or al, al
   441 000001CA 7406                <1> 			jz .endloop ; If character is a null character aka 0 then end the loop			
   442 000001CC B40E                <1> 			mov ah, 0Eh ; ah = 0x0e
   443 000001CE CD10                <1> 			int 0x10 ; print character
   444 000001D0 EBF5                <1> 			jmp .loop ; Go back to the beginning of the loop
   445                              <1> 	.endloop:
   446 000001D2 61                  <1> 	popa ; Pop all the saved registers on the stack and restore them!
   447 000001D3 CF                  <1> iret ; Return from interrupt
   448                              <1> 
   449                              <1> ;------------------------------------------------------------------------------------------------------
   450                                  
   451                                  
   452                                  
   453                                  main:
   454                                  
   455 000001D4 E82CFE                  call init_int
   456                                  
   457 000001D7 31C0                    xor ax, ax ; make it zero
   458 000001D9 8ED8                    mov ds, ax ; Data segment is zero
   459 000001DB 8EC0                    mov es, ax
   460                                  
   461                                  
   462                                  
   463                                  ; Clear Screen
   464                                  
   465 000001DD CD27                    int 27h
   466                                  
   467                                  ;Set desired background color (Green)
   468 000001DF B40B                    mov ah, 0x0b 
   469 000001E1 B700                    mov bh, 0
   470 000001E3 B302                    mov bl, 2
   471 000001E5 CD10                    int 0x10	
   472                                  
   473                                  
   474                                  
   475                                  
   476                                  hang:
   477                                  	
   478                                  	;mov ax, buffer
   479                                  	;mov bx, 8 ; Length
   480                                  	;int 24h ;ZERO(buffer)
   481                                  	
   482                                  
   483                                  	; Print Desired Message
   484                                  
   485 000001E7 B8[2F02]                	mov ax, cli_msg
   486 000001EA B700                    	mov bh, 0
   487 000001EC B30F                    	mov bl, 0xf
   488                                  
   489 000001EE CD21                    	int 21h ; print ax=msg bl=blue
   490                                  
   491                                  	; Get Input
   492 000001F0 BB[5904]                	mov bx, buffer
   493 000001F3 CD22                    	int 22h ; Read From Keyboard  And Store String In Buffer
   494                                  	
   495 000001F5 BB[5904]                	mov bx, buffer
   496 000001F8 B8[2904]                	mov ax, internal_command_A
   497                                  	
   498 000001FB CD30                    	int 30h ; string compare buffer and commandA
   499                                  	
   500 000001FD 83FA00                  	cmp dx, 0 
   501                                  	
   502 00000200 7411                    	je help_command ;if (buffer == command) goto help_command
   503                                  	
   504 00000202 BB[5904]                	mov bx, buffer
   505 00000205 B8[2E04]                	mov ax, internal_command_B
   506                                  	
   507 00000208 CD30                    	int 30h ; string compare buffer and commandB
   508                                  	
   509 0000020A 83FA00                  	cmp dx, 0 
   510                                  	
   511 0000020D 7512                    	jne invalid
   512                                  
   513                                  clear_commmand:
   514                                  
   515                                  		; Clear Screen
   516                                  
   517 0000020F CD27                    		int 27h
   518                                  		
   519 00000211 EBD4                    		jmp hang
   520                                  	
   521                                  help_command:
   522                                  
   523 00000213 CD23                    		int 23h ; Print newline
   524                                  
   525 00000215 B8[3D02]                		mov ax, help_msg
   526 00000218 BB0F00                  		mov bx, 000fh
   527 0000021B CD21                    		int 21h ; Print help string
   528                                  
   529 0000021D CD23                    		int 23h ; Print newline
   530                                  		
   531 0000021F EBC6                    		jmp hang
   532                                  	
   533                                  invalid:
   534                                  	
   535 00000221 CD23                    	int 23h ; Print newline
   536                                  
   537                                  	
   538 00000223 B8[3404]                	mov ax, invalid_cmd
   539 00000226 BB0F00                  	mov bx, 000fh
   540 00000229 CD21                    	int 21h ; Print invalid command message
   541                                  
   542 0000022B CD23                    	int 23h ; Print newline
   543                                  
   544                                  	
   545 0000022D EBB8                    	jmp hang
   546                                  	
   547 0000022F 0D0A4D6F6E73746572-     cli_msg: db 13, 10, 'MonsterOS> ', 0
   548 00000238 4F533E2000         
   549 0000023D 57656C636F6D652074-     help_msg: db 'Welcome to the MonsterOS shell prompt.', 13, 10, 13, 10, 'MonsterOS shell prompt contains only two internal commands: help and clear.', 13, 10, 'This means that MonsterOS treats everything else that is
   550 00000246 6F20746865204D6F6E-
   551 0000024F 737465724F53207368-
   552 00000258 656C6C2070726F6D70-
   553 00000261 742E0D0A0D0A4D6F6E-
   554 0000026A 737465724F53207368-
   555 00000273 656C6C2070726F6D70-
   556 0000027C 7420636F6E7461696E-
   557 00000285 73206F6E6C79207477-
   558 0000028E 6F20696E7465726E61-
   559 00000297 6C20636F6D6D616E64-
   560 000002A0 733A2068656C702061-
   561 000002A9 6E6420636C6561722E-
   562 000002B2 0D0A54686973206D65-
   563 000002BB 616E73207468617420-
   564 000002C4 4D6F6E737465724F53-
   565 000002CD 207472656174732065-
   566 000002D6 766572797468696E67-
   567 000002DF 20656C736520746861-
   568 000002E8 74206973206E6F7420-
   569 000002F1 7468652068656C702F-
   570 000002FA 636C65617220636F6D-
   571 00000303 6D616E642061732061-
   572 0000030C 6E2065787465726E61-
   573 00000315 6C20636F6D6D616E64-
   574 0000031E 2E0D0A416E20657874-
   575 00000327 65726E616C20636F6D-
   576 00000330 6D616E642069732062-
   577 00000339 61736963616C6C7920-
   578 00000342 612066696C656E616D-
   579 0000034B 65206F662061206669-
   580 00000354 6C652073746F726564-
   581 0000035D 206F6E207468652064-
   582 00000366 69736B2E0A0D496620-
   583 0000036F 7468652066696C6520-
   584 00000378 6973206C6F63617465-
   585 00000381 64206F6E2074686520-
   586 0000038A 6469736B2069742069-
   587 00000393 732065786563757465-
   588 0000039C 642069662069742069-
   589 000003A5 7320612070726F6772-
   590 000003AE 616D3B20656C736520-
   591 000003B7 697420697320747265-
   592 000003C0 617465642061207465-
   593 000003C9 78742066696C652061-
   594 000003D2 6E642069747320636F-
   595 000003DB 6E74656E7473206172-
   596 000003E4 6520646973706C6179-
   597 000003ED 65642E0D0A4966206E-
   598 000003F6 6F2066696C65206973-
   599 000003FF 20666F756E64207468-
   600 00000408 656E2061206572726F-
   601 00000411 72206D657373616765-
   602 0000041A 20697320646973706C-
   603 00000423 617965642E00       
   604 00000429 68656C7000              internal_command_A: db 'help', 0
   605 0000042E 636C65617200            internal_command_B: db 'clear', 0
   606 00000434 496E76616C69642049-     invalid_cmd: db 'Invalid Internal / External Command!',0
   607 0000043D 6E7465726E616C202F-
   608 00000446 2045787465726E616C-
   609 0000044F 20436F6D6D616E6421-
   610 00000458 00                 
   611 00000459 00<rept>                buffer: times 8 db 0
   612                                  
